---
title: "Chapter One- Observational Study of Milkweed Reproductive Success along Toronto Urban-Rural Gradient."
author: "Sophie Breitbart"
date: "12/22/2020"
output:
  html_document:
    number_sections: true
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float:
      collapsed: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: console

- remember to do renv::snapshot() before quitting
---

# Set up notebook
## Install, load packages
```{r message=FALSE, warning=FALSE}
# devtools::install_github("cardiomoon/ggiraphExtra")
# devtools::install_github("dkahle/ggmap")
# devtools::install_github("hadley/devtools")
# install.packages("agricolae")
# install.packages("BH")
# install.packages("car")
# install.packages("cowplot")
# install.packages("digest", type="source")
# install.packages("dplyr")
# install.packages("factoextra")
# install.packages("flextable")
# install.packages("geosphere")
# install.packages("ggiraphExtra")
# install.packages("ggpubr")
# install.packages("ggsn")
# install.packages("ggspatial")
# install.packages("GISTools")
# install.packages("ISLR")
# install.packages("janitor")
# install.packages("lindia")
# install.packages("lme4")
# install.packages("lmerTest")
# install.packages("mnormt")
# install.packages("patchwork")
# install.packages("plogr")
# install.packages("psych")
# install.packages("RcppEigen")
# install.packages("rpart")
# install.packages('sjPlot')
# install.packages('stargazer')
# install.packages("swirl")
# install.packages("tibble")
# install.packages("tidyverse")
# install.packages("vegan")
# install.packages("XLConnect")
# install.packages('backports')
# install.packages(c("slidify", "ggplot2", "devtools"))
# install.packages('maps')
# install.packages('rmarkdown')
# install_github("vqv/ggbiplot")
library("FactoMineR")
library("tibble", lib.loc="~/R/win-library/3.5")
library(agricolae)
library(apaTables)
library(car)
library(data.table)
library(devtools)
library(dplyr)
library(e1071)
library(factoextra)
library(flextable)
library(forcats)
library(geosphere)
library(ggbiplot)
library(ggmap)
library(ggpubr)
library(ggsn)
library(ggspatial)
library(GISTools)
library(gridExtra)
library(here)
library(Hmisc)
library(hrbrthemes)
library(ISLR)
library(janitor)
library(lindia)
library(lme4)
library(lmerTest)
library(lsmeans)
library(MASS)
library(multcomp)
library(MuMIn)
library(nlme)
library(patchwork)
library(plyr)
library(reshape)
library(reshape2)
library(rpart)
library(sjPlot)
library(stargazer)
library(tibble)
library(tidyr)
library(tidyverse)
library(vegan)
library(viridis)
require(ggiraph)
require(ggiraphExtra)
require(ggplot2)
require(MASS)
require(scales)

```

## Import data
```{r, import}
Transect_Data <- read.csv(here("./raw_data/Transect_Milkweed_Data_2018_and_2019_endofseason.csv"),  header=T, na.strings=c("","NA"))

```

### Add City_dist values with Haversine formula
```{r}
# Ref lat and longs are for Yonge & Dundas intersection in downtown Toronto
Transect_Data$Ref_Lat <- "43.656327"
Transect_Data$Ref_Long <- "-79.380904"

# Make lat/long cols numeric
Transect_Data$Latitude <- as.numeric(as.character(Transect_Data$Latitude))
Transect_Data$Longitude <- as.numeric(as.character(Transect_Data$Longitude))
Transect_Data$Ref_Lat <- as.numeric(as.character(Transect_Data$Ref_Lat))
Transect_Data$Ref_Long <- as.numeric(as.character(Transect_Data$Ref_Long))

# Find distances from Yonge/Dundas to sample sites (in meters)
Transect_Data <- Transect_Data %>% mutate(CTD_m = distHaversine(cbind(Longitude, Latitude), cbind(Ref_Long, Ref_Lat)))

# conver to km
Transect_Data$City_dist <- Transect_Data$CTD / 1000

# drop ref lat, long, and city_dist (in m) cols
Transect_Data <- Transect_Data[,-c(39:41)]

```

## Clean data file
```{r message=FALSE, warning=FALSE}

# Other_pod_lengths column has all pod lengths for one plant, separated by commas.
# This line of code separates them into their own columns. Ex. first pod length goes into "OPodL1", etc.
# The plant with the most pods had 21 (including the collected pod, which has its own category ("Collected_pod_length"), so there should be one less than 21 columns for the remaining pod's lengths: 20 columns in total.)
Transect_Data_18_19 <- NULL
Transect_Data_18_19 <- separate(Transect_Data, Other_pod_lengths, into = c("OPodL1", "OPodL2", "OPodL3", "OPodL4", "OPodL5", "OPodL6", "OPodL7", "OPodL8", "OPodL9", "OPodL10", "OPodL11", "OPodL12", "OPodL13", "OPodL14", "OPodL15", "OPodL16", "OPodL17", "OPodL18", "OPodL19", "OPodL20"), sep = ",")

# Neaten first column's name
colnames(Transect_Data_18_19)[1] <- "Year"

# Replace x's (which denote no data) with NA
Transect_Data_18_19[Transect_Data_18_19 == "x"] <- NA

# Convert appropriate column types to character and then numeric.
to_char_num <- c(5:14, 21:23,25,28:29,31,33:54, 56)
Transect_Data_18_19[to_char_num] <- lapply(Transect_Data_18_19[to_char_num], as.character)
Transect_Data_18_19[to_char_num] <- lapply(Transect_Data_18_19[to_char_num], as.numeric)

# Convert appropriate column types to integer.
to_int <- c(1,18,24,30:32,55)
Transect_Data_18_19[to_int] <- lapply(Transect_Data_18_19[to_int], as.integer)

# check column types are correct
colnames(Transect_Data_18_19)[14] <- "Height_July"
colnames(Transect_Data_18_19)[28] <- "Height_Sept"

# str(Transect_Data_18_19)

# Export csv of pop IDs and city distances
Transect_Data_18_19[,c("Pop_ID", "City_dist", "Transect_ID")] %>%
  group_by(Pop_ID) %>%
  dplyr::summarise(
    City_dist=first(City_dist),
    Transect_ID=first(Transect_ID)) %>%
  write.csv(.,file = "~/R_Projects/Chapter1/Sites_distances.csv")

```

## Add average pollen removal and pod length columns
```{r}
## Add "Average Pollinia" column to master dataset and move it after other pollinia columns
# Add new column for average pollinia removal per plant per year
Transect_Data_18_19$Average_Pollinia <- NA

# Move this new column after columns for pollinia removed per flower
Transect_Data_18_19 = Transect_Data_18_19[, c(1:13, 58, 14:57)]

# Make the column numeric
Transect_Data_18_19$Average_Pollinia <- as.numeric(as.character(Transect_Data_18_19$Average_Pollinia))

# Calculate average pollinia removed. Missing flowers excluded from calculation. Ex. the average pollinia removed for a plant with 9 "readable" flowers are averaged over 9. If the plant only had 3 "readable" flowers, the mean is averaged over 3.
Transect_Data_18_19[14] <- rowMeans(Transect_Data_18_19[,5:13], na.rm = TRUE)


#######################################################################


## Adding average pod length column (only applies to data collected in 2019; pod lengths were not measured in 2018.)

Transect_Data_18_19$Average_pod_length <- NA
Transect_Data_18_19$Average_pod_length <- rowMeans(Transect_Data_18_19[,35:54], na.rm = TRUE)
# write.csv(Transect_Data_18_19,'Transect_Data_18_19_avgpodlengths.csv')
```

## Variable key

* Average_Pollinia
: Average number of pollinia removed per flower, per plant, per population (0-5). Was measured in July of 2018 and 2019.

* City_dist
: Population's distance from urban center (Yonge & Dundas in Toronto), in kilometers.

* Transect_ID
: + Northern urban transect,
: + Southern urban transect (which follows green corridors including railroad tracks, trails, hydro lines, etc.), or
: + Rural transect.

    See [link](https://www.google.com/maps/d/u/0/edit?hl=en&mid=1T6o02xqdFY49LpaV5fgpNYcgUNfy6hWJ&ll=43.54856560494681%2C-79.7330821595105&z=10) for a map of the 3 transects.  
  
* Peduncles
: Average number of peduncles per plant per population

* Height_July
: Average height of sampled plants in July (when performing pollinia removal survey), in centimeters

* Plants_present_2018
: Number of plants present at the sampling site in 2018. Populations were spaced at least 500 meters apart to ensure population distinction.

* Height_Sept
: Average height of sampled plants in September (when performing follicle, peduncle survey), in centimeters

* Viable_Pods
: Average number of viable follciles per plant per population. These follicles were usually around 6-10 cm long, compared to aborted follicles, which were usually about 1 cm long and seemed to have stopped growing based on size and color (oftentimes brown/dried up).

* Total_Pods
: Average number of *combined* viable and aborted follciles per plant per population. In 2018, we did not distinguish between aborted and viable follicles, so this variable is used to compare follicle production over both years. Viable follicle production can only be measured for 2019 alone.

* nPlants
: Number of plants sampled per population.

* Average_pod_length
: Average length of all pods measured on surveyed plants in 2019, in centimeters. This data was not collected in 2018. In 2019, it was collected to understand whether there is a relationship between pod dimensions and seed number and/or seed mass. (As of October 2019, it seems there is a surprisingly weak relationship.)

## Make summary table showing average values per population
```{r}
# make summary table for several variables PER POPULATION
AvgVars_byPatch <- Transect_Data_18_19[,c("Patch_ID","Average_Pollinia", "City_dist", "Transect_ID", "Year", "Height_July", "Area_sq_m_2018", "Plants_present_2018", "Height_Sept", "Viable_Pods", "Total_Pods", "Peduncles", "Average_pod_length")] %>% group_by(Patch_ID, Year) %>%
    dplyr::summarise(
      Average_Pollinia=mean(Average_Pollinia,na.rm = TRUE),
      City_dist=mean(City_dist),
      Transect_ID=first(Transect_ID),
      Peduncles=mean(Peduncles,na.rm = TRUE),
      Height_July=mean(Height_July,na.rm = TRUE),
      Area_sqm_18=first(Area_sq_m_2018,na.rm = TRUE),
      Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
      Height_Sept=mean(Height_Sept,na.rm = TRUE),
      Viable_Pods=mean(Viable_Pods,na.rm = TRUE),
      Total_Pods=mean(Total_Pods,na.rm = TRUE),
      nPlants=n(),
      Average_pod_length=mean(Average_pod_length, na.rm=TRUE)
      )
# Check column types are correct
# str(AvgVars_byPatch)

# Neaten first column's name
AvgVars_byPatch$Year <- as.factor(AvgVars_byPatch$Year)

# Find plant density per site
AvgVars_byPatch$density_sqm_18 <- AvgVars_byPatch$Area_sqm_18 / AvgVars_byPatch$Plants_present_2018

# Create 2 other data frames: One for only 2018 data, the other with only 2019 data
AvgVars_byPatch_2018 <- AvgVars_byPatch[which(AvgVars_byPatch$Year == "2018"), ]
AvgVars_byPatch_2019 <- AvgVars_byPatch[which(AvgVars_byPatch$Year == "2019"), ]


```

## **Making new table that doesn't have an average pollinia row: each flower is own row
```{r}
# make table wide to long so each flower has own row
long_Transect_Data_18_19 <- gather(Transect_Data_18_19, Inflor_flower, Pollinia_removed, Pollinia_1_1:Pollinia_3_3, factor_key=TRUE)

# remove "Pollinia_" from Flower column
long_Transect_Data_18_19$Inflor = substr(long_Transect_Data_18_19$Inflor_flower,10,10)
long_Transect_Data_18_19$Flower = substr(long_Transect_Data_18_19$Inflor_flower,12,12)

# remove "Inflor_flower" column
long_Transect_Data_18_19 <- subset(long_Transect_Data_18_19, select = -c(Inflor_flower))

# Make the 3 new columns numeric
long_Transect_Data_18_19$Inflor <- as.numeric(as.character(long_Transect_Data_18_19$Inflor))
long_Transect_Data_18_19$Pollinia_removed <- as.numeric(as.character(long_Transect_Data_18_19$Pollinia_removed))
long_Transect_Data_18_19$Flower <- as.numeric(as.character(long_Transect_Data_18_19$Flower))

# reorder columns so new cols are near beginning of df
long_Transect_Data_18_19 <- long_Transect_Data_18_19[,c(1:4, 50:53, 49, 5:48)]

# make patch ID, plant, and inflor cols factors
long_Transect_Data_18_19$Patch_ID <- as.factor(as.character(long_Transect_Data_18_19$Patch_ID))
long_Transect_Data_18_19$Plant_Num <- as.factor(as.character(long_Transect_Data_18_19$Plant_Num))
long_Transect_Data_18_19$Inflor <- as.factor(as.character(long_Transect_Data_18_19$Inflor))

# make pollinia removed an integer
long_Transect_Data_18_19$Pollinia_removed <- as.integer(as.character(long_Transect_Data_18_19$Pollinia_removed))

# separate 2018-2019
long_Transect_Data_18 <- filter(long_Transect_Data_18_19, Year == "2018")
long_Transect_Data_19 <- filter(long_Transect_Data_18_19, Year == "2019")
```



## SummarySE
```{r}
## summary of pollinia removed per inflorescence
long_summary_inflor <- summarySE(long_Transect_Data_18_19,
                          measurevar= 'Pollinia_removed',
                          groupvars = c('Year', 'Patch_ID', 'City_dist', 'Transect_ID', 'Plant_Num', 'Inflor'))

## summary of pollinia removed per plant
long_summary_plant <- summarySE(long_Transect_Data_18_19,
                          measurevar= 'Pollinia_removed',
                          groupvars = c('Year', 'Patch_ID', 'City_dist', 'Transect_ID', 'Plant_Num'))

## summary of pollinia removed per pop
long_summary_pop <- summarySE(long_Transect_Data_18_19,
                          measurevar= 'Pollinia_removed',
                          groupvars = c('Year', 'Patch_ID', 'City_dist', 'Transect_ID'))

### change column "n" to "flowers_read"
names(long_summary_pop)[5] <- "Flowers_read"

### remove rows w/NAs
long_sum <- long_summary_pop %>% filter(!is.na(Pollinia_removed))

```

## **Adjusting long table from previous chunk for pods/peds analyses (removing sterile pops)
### Remove sterile populations
#### For population-level table
```{r}

# First, find populations that are "sterile"- no plants w/pods or flowers per year
No_flowers <- AvgVars_byPatch[is.na(AvgVars_byPatch$Average_Pollinia) & (is.na(AvgVars_byPatch$Total_Pods) | (AvgVars_byPatch$Total_Pods == 0)),]

# Then, remove if population only has 1 year's records in this df (i.e. it was only "sterile" for one year)
## sterile_pops_bothyears only includes rows with the 2019 data from the sterile populations, but it was essential for making the list version of this dataframe's Patch_ID row (next line)
sterile_pops_bothyears <- No_flowers[duplicated(No_flowers[c("Patch_ID")]),]
sterile_pops_bothyears_list <- sterile_pops_bothyears$Patch_ID

# Populations that were sterile for any given year
sterile_pops_18 <- No_flowers[which(No_flowers$Year == "2018"),]
sterile_pops_19 <- No_flowers[which(No_flowers$Year == "2019"),]

# New dataframe with all records for fertile populations (i.e. all populations - sterile)
fertile_pops_all <- AvgVars_byPatch %>% 
  filter(!Patch_ID %in% sterile_pops_bothyears_list)


# check that fertile_pops_all has no populations in common with sterile_pops_bothyears
overlap_check <- inner_join(sterile_pops_bothyears, fertile_pops_all)
# this new df is empty = confirmed exclusivity of sterile and fertile dataframes.


# Populations that were fertile for any given year
fertile_pops_18 <- fertile_pops_all[which(fertile_pops_all$Year == "2018"),]
fertile_pops_19 <- fertile_pops_all[which(fertile_pops_all$Year == "2019"),]


```

#### For flower-level table
```{r}
# remove rows with cells that match both the year and population of sterile pops list
sterile_list <- as.list(sterile_pops_bothyears %>% dplyr::select(Patch_ID))

## THIS LISTS EACH ROW AS A FLOWER... BE CAREFUL
fertile_long <- subset(long_Transect_Data_18_19,
                       long_Transect_Data_18_19$Patch_ID != sterile_list)

# separate 2018-2019
fertile_long_18 <- filter(fertile_long, Year == "2018")
fertile_long_19 <- filter(fertile_long, Year == "2019")


fertile <- anti_join(Transect_Data_18_19, sterile_pops_bothyears, by = "Patch_ID")
fertile_urban <- fertile %>% filter(Transect_ID != 'Rural')
```

## Dataframes excluding "empty" populations (for pollen removal dataset, pops w/o any flowers... for follicle dataset, pops w/o any follicles... etc.)
```{r}
# Make new data frames of 2018 & 2019 pollinia removal data that excludes empty pops
AvgVars_notNA_Poll_18 <- AvgVars_byPatch_2018[!is.na(AvgVars_byPatch_2018$Average_Pollinia),]
AvgVars_notNA_Poll_19 <- AvgVars_byPatch_2019[!is.na(AvgVars_byPatch_2019$Average_Pollinia),]

# Make new data frames of 2018 & 2019 follicle data that excludes pops w/o any pods
AvgVars_notNA_Pod_18 <- fertile_pops_18[!is.na(fertile_pops_18$Total_Pods),]
AvgVars_notNA_Pod_19 <- fertile_pops_19[!is.na(fertile_pops_19$Total_Pods),]

# Make new data frames of 2018 & 2019 peduncle data that excludes pops without any pods
AvgVars_notNA_Ped_18 <- fertile_pops_18[!is.na(fertile_pops_18$Peduncles),]
AvgVars_notNA_Ped_19 <- fertile_pops_19[!is.na(fertile_pops_19$Peduncles),]
```

## Add dataframe with urbanization scores, add to existing dfs
```{r}
# Import urb_index values for each of these rows
urb_scores <- read.csv(here("./Figures_Tables/UrbanizationScore/Urbanization_Scores_Table.csv"),  header=T, na.strings=c("","NA"))

Pops_patches_all <- Transect_Data[,c(2,3)] %>% dplyr::distinct()
Pops_patches <- Pops_patches_all %>% group_by(Patch_ID) %>%
  dplyr::summarise(
    Pop_ID = first(Pop_ID))

urb_scores <- dplyr::inner_join(urb_scores, Pops_patches, by = "Pop_ID") %>% dplyr::select(., -Patch_ID.y) %>% dplyr::rename(., Patch_ID = Patch_ID.x)

#===============================================================#
#                            (g)lm datasets                     #
#===============================================================#

## Pollen removal------------------------
### gradient
urb_scores_poll_all <- dplyr::left_join(AvgVars_notNA_Poll_18_19, urb_scores, by = "Patch_ID")
### urban subs
urb_scores_poll <- dplyr::left_join(AvgVars_notNA_Poll_18_19_urban, urb_scores, by = "Patch_ID")

## Pods------------------------
### gradient
urb_scores_pods_all <- dplyr::left_join(fertile_pops_all_notNApods, urb_scores, by = "Patch_ID")
### urban subs
urb_scores_pods <- dplyr::left_join(fertile_pops_all_notNApods_urban, urb_scores, by = "Patch_ID")


## Peduncles------------------------
### gradient
urb_scores_peds_all <- dplyr::left_join(fertile_pops_all_notNApeds, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_peds <- dplyr::left_join(fertile_pops_all_notNApeds_urban, urb_scores, by = "Patch_ID")


## Height------------------------
### gradient
urb_scores_height_all <- dplyr::left_join(fertile_pops_all_height_18_19_sept, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_height <- dplyr::left_join(fertile_pops_all_height_18_19_urban_sept, urb_scores, by = "Patch_ID")


## Pods/ped------------------------
### gradient
urb_scores_podperped_all <- dplyr::left_join(fertile_pops_all_podsperped, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_podperped <- dplyr::left_join(fertile_pops_all_podsperped_urban, urb_scores, by = "Patch_ID")


#===============================================================#
#                            (g)lmer datasets                   #
#===============================================================#

# Pollen removal------------------------
### gradient
urb_scores_poll_long <- dplyr::left_join(long_Transect_Data_18_19, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_poll_all_long <- dplyr::left_join(long_urban, urb_scores, by = "Patch_ID")

## Pods------------------------
### gradient
fertile_pops_all_notNApods <- fertile_pops_all[!is.na(fertile_pops_all$Viable_Pods),]
urb_scores_pods_long <- dplyr::left_join(fertile, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_pods_all_long <- dplyr::left_join(fertile_urban, urb_scores, by = "Patch_ID")


## Peduncles------------------------
### gradient
urb_scores_peds_long <- dplyr::left_join(fertile, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_peds_all_long <- dplyr::left_join(fertile_urban, urb_scores, by = "Patch_ID")


## Height------------------------
### gradient
urb_scores_height_long <- dplyr::left_join(fertile, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_height_all_long <- dplyr::left_join(fertile_urban, urb_scores, by = "Patch_ID")


## Pods/ped------------------------
### gradient
urb_scores_podsperped_long <- dplyr::left_join(fertile, urb_scores, by = "Patch_ID")

### urban subs
urb_scores_podsperped_all_long <- dplyr::left_join(fertile_urban, urb_scores, by = "Patch_ID")

```

# Methods
## Sampling site map
```{r}
# REMOVE API KEY EVENTUALLY
ggmap::register_google(key = "AIzaSyDa0p-isKca8Plhs2zSy5inHG9LQTb0MEs")

sites_all <- read.csv(here("./raw_data/80_Sites.csv"), sep = ",", header = TRUE)
sites <- sites_all[,2:5]
sites <- sites[c(1:5,10,14,17,21:93),]
# sbbox <- make_bbox(lon = sites$lon, lat = sites$lat, f = .1)

sites$Transect <- factor(sites$Transect , levels = c("North", "South", "Rural"))

##### MAIN MAP #####
### STAMEN TERRAIN MAP ###
mylocation <- c(-80.19, 43.2, -79.2, 43.81)
base_map <- ggmap(get_map(location = mylocation, maptype = 'terrain', source = 'stamen'))
cols1 <- c("North" = "#FDE725FF", "South" = "#21908CFF", "Rural" = "#660099")

map1 <- base_map +
  geom_point(data = sites, mapping = aes(x = lon, y = lat, fill=Transect, shape=Transect), color = "black", size=3) +
  labs(x = 'Longitude', y = 'Latitude') +
   scalebar(x.min = -80.19, x.max = -79.25,
            y.min = 43.25, y.max = 43.8,
            dist = 10, dist_unit = "km",
            st.bottom = FALSE, st.color = "black",
            transform = TRUE, model = 'WGS84',
            st.dist=.03) +
   theme(legend.position = c(0.8, 0.3),
         legend.background = element_rect(fill = "white",colour = "black"),
         legend.box.margin = margin(6, 6, 6, 6),
         legend.text = element_text(size=12),
         legend.title = element_text(size = 14),
         axis.text=element_text(size=12),
         axis.title=element_text(size=14)) +
   scale_fill_manual(values = cols1,
                     breaks = c("North", "South", "Rural"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
                       name = "Sample Site Transect") +
   scale_shape_manual(values = c(23,24,21),
                      breaks = c("North", "South", "Rural"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
                       name = "Sample Site Transect") 
   
 
north2(map1, x = .59, y = .2, scale = 0.11, symbol = 1)
dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/SampleSiteMap_terrain_color.pdf", width = 7, height = 5)

### GOOGLE SATELLITE MAP ###
base_map2 <- ggmap(get_map(location = mylocation, maptype = 'satellite', source = 'google'))
cols2 <- c("North" = "#E69F00", "South" = "#F0E442", "Rural" = "#D55E00")

map1_satellite <- get_googlemap(center = c(lon = -79.74256, lat = 43.5421), zoom = 10, maptype = 'satellite') %>% ggmap() +
  geom_point(data = sites, mapping = aes(x = lon, y = lat, fill=Transect, shape=Transect), color = "black", size=3) +
  labs(x = 'Longitude', y = 'Latitude') +
   scalebar(x.min = -80.19, x.max = -79.35,
            y.min = 43.42, y.max = 43.75,
            dist = 10, dist_unit = "km",
            st.bottom = FALSE, st.color = "black",
            transform = TRUE, model = 'WGS84',
            st.dist=.03) +
   theme(legend.position = c(0.8, 0.15),
         legend.background = element_rect(fill = "white",colour = "black"),
         legend.box.margin = margin(6, 6, 6, 6),
         legend.text = element_text(size=12),
         legend.title = element_text(size = 14),
         axis.text=element_text(size=12),
         axis.title=element_text(size=14)) +
   scale_fill_manual(values = cols2,
                     breaks = c("North", "South", "Rural"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
                       name = "Sample Site Transect") +
   scale_shape_manual(values = c(23,24,21),
                      breaks = c("North", "South", "Rural"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
                       name = "Sample Site Transect") 

north2(map1_satellite, x = .7, y = .5, scale = 0.11, symbol = 1)
dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/SampleSiteMap_satellite_color.pdf", width = 10, height = 7)

##### moving the scale bar & new colors #####
# map1_satellite <- get_googlemap(center = c(lon = -79.74256, lat = 43.5421), zoom = 10, maptype = 'satellite') %>% ggmap() +
#   geom_point(data = sites, mapping = aes(x = lon, y = lat, fill=Transect, shape=Transect), color = "black", size=3) +
#   labs(x = 'Longitude', y = 'Latitude') +
#    scalebar(x.min = -80.19, x.max = -79.4,
#             y.min = 43.25, y.max = 43.8,
#             dist = 10, dist_unit = "km",
#             st.bottom = FALSE, st.color = "black",
#             transform = TRUE, model = 'WGS84',
#             st.dist=.03) +
#    theme(legend.position = c(0.8, 0.3),
#          legend.background = element_rect(fill = "white",colour = "black"),
#          legend.box.margin = margin(6, 6, 6, 6),
#          legend.text = element_text(size=12),
#          legend.title = element_text(size = 14),
#          axis.text=element_text(size=12),
#          axis.title=element_text(size=14)) +
#    scale_fill_manual(values = cols1,
#                      breaks = c("North", "South", "Rural"),
#                        labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
#                        name = "Sample Site Transect") +
#    scale_shape_manual(values = c(23,24,21),
#                       breaks = c("North", "South", "Rural"),
#                        labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
#                        name = "Sample Site Transect") 




###### incorrect satellite map code #####
 # map1_satellite <- base_map2 +
 #  geom_point(data = sites, mapping = aes(x = lon, y = lat, fill=Transect, shape=Transect), color = "black", size=3) +
 #  labs(x = 'Longitude', y = 'Latitude') +
 #   scalebar(x.min = -80.19, x.max = -79.25,
 #            y.min = 43.25, y.max = 43.8,
 #            dist = 10, dist_unit = "km",
 #            st.bottom = FALSE, st.color = "black",
 #            transform = TRUE, model = 'WGS84',
 #            st.dist=.03) +
 #   theme(legend.position = c(0.8, 0.3),
 #         legend.background = element_rect(fill = "white",colour = "black"),
 #         legend.box.margin = margin(6, 6, 6, 6),
 #         legend.text = element_text(size=12),
 #         legend.title = element_text(size = 14),
 #         axis.text=element_text(size=12),
 #         axis.title=element_text(size=14)) +
 #   scale_fill_manual(values = cols1,
 #                     breaks = c("North", "South", "Rural"),
 #                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
 #                       name = "Sample Site Transect") +
 #   scale_shape_manual(values = c(23,24,21),
 #                      breaks = c("North", "South", "Rural"),
 #                       labels = c("Urban: Non-Corridor", "Urban: Corridor", "Rural"),
 #                       name = "Sample Site Transect") 


##### MAIN MAP- black and white #####
cols <- c("North" = "gray72", "South" = "gray33", "Rural" = "white")

 map2 <- base_map +
  scale_fill_manual(values = cols) +
  scale_shape_manual(values = c(23,24,21)) +
  geom_point(data = sites, mapping = aes(x = lon, y = lat, shape=Transect, fill = Transect), color = "black", size=3) +
  labs(x = 'Longitude', y = 'Latitude') +
   scalebar(x.min = -80.19, x.max = -79.25,
            y.min = 43.25, y.max = 43.8,
            dist = 10, dist_unit = "km",
            st.bottom = FALSE, st.color = "black",
            transform = TRUE, model = 'WGS84',
            st.dist=.03) +
   theme(legend.position = c(0.9, 0.3),
         legend.background = element_rect(fill = "white",colour = "black"),
         legend.box.margin = margin(6, 6, 6, 6)) 


north2(map2, x = .7, y = .3, scale = 0.11, symbol = 1)




# ##### INSET OF ONTARIO #####
# logo_file <- system.file("extdata", "logo.png", package = "cowplot")
# 
# ggdraw(p) + 
#   draw_image(logo_file, x = 1, y = 1, hjust = 1, vjust = 1, width = 0.13, height = 0.2)


```


## GTA LULC
```{r}

################# Tried obtaining Toronto's LULC dataset directly from the website but am having issues, so I downloaded it. (see code below) ###########

# install.packages("opendatatoronto")
# library(opendatatoronto)
# library(dplyr)
# 
# # get package
# package <- show_package("61642048-56bb-4050-b7c3-f569fcf94527")
# package
# 
# lulc_gta <- list_package_resources(package$id)
# lulc_gta_shp <- get_resource(lulc_gta[3,])

# 
# library(rgdal)
# my_spdf <- readOGR( 
#   dsn= paste0(getwd(),"~/R_Projects/TorontoOpenData_ForestandLandCover2018_20200916/cotlandcover/") , 
#   layer="cotLandcover",
#   verbose=FALSE
# )
# 
# library(raster)
# s <- shapefile("~/R_Projects/TorontoOpenData_ForestandLandCover2018_20200916/cotlandcover/cotLandcover.shp")
# 
# 
# # Basic plot of shapefile:
# par(mar=c(0,0,0,0))
# plot(s, col="#f2f2f2", bg="skyblue", lwd=0.25, border=0 )
# 
# install.packages("rmapshaper")
# library(rmapshaper)
# shape_simp <- rmapshaper::ms_simplify((raster::shapefile("~/R_Projects/TorontoOpenData_ForestandLandCover2018_20200916/cotlandcover/cotLandcover.shp")), keep = 0.005)
```

## Sampling design stats
### How many plants are within transects?
```{r}
# For the southern urban (green corridor) subtransect, these sites are within the green corridor: MW032, MW014, MW013, MW003, MW004, MW069, MW050
# **MW013 isn't technically within the green corridor itself but it's perpendicular and connected through a different green corridor, so I'm counting it. It's ~100m from the corridor.

# 29 southern urban sites total, 7 within the corridor itself (<25%)
```

### Histograms of green corridor site proximities
```{r}
library(ggplot2)
library(dplyr)

corridor_data <- read.csv(here("./Corridor_Analysis/SouthernUrbanSites_ProximitytoCorridor.csv"),  header=T, na.strings=c("","NA"))


corridor_data %>%
  ggplot( aes(x=Distance, fill = Corr_or_greenspace)) +
    geom_histogram( alpha=0.5, position = 'identity', binwidth = 50) +
  facet_wrap(~Corr_or_greenspace) +
  scale_x_continuous(name="Site Distance to...",
                     breaks = seq(0,2800,500),
                     labels = seq(0,2800,500)) +
  theme(legend.position = 'none')

corr_dist <- (corridor_data$Distance)
bins <- seq(0,2700,by=50)
corr_table <- cut(corr_dist,bins)
# transform(table(corr_table))

corr_table1<- with(corridor_data, table(Corr_or_greenspace, cut(Distance, bins, include.lowest = TRUE)))
# transform(corr_table1)
library(data.table)
corr_df <- setDT(corridor_data)[, .N, by = .(Corr_or_greenspace, Bin = cut(Distance, bins, include.lowest = TRUE))] 

corr_df_spread <- tidyr::spread(corr_df, Corr_or_greenspace, N)

corr_df_spread$Percent_Corridor <- as.numeric(corr_df_spread$Corridor) / .34
corr_df_spread$Percent_Greenspace <- as.numeric(corr_df_spread$Greenspace) / .34
corr_df_spread[is.na(corr_df_spread)] <- 0
corr_df_spread$Perc_Corr_Cumulative <- cumsum(corr_df_spread[, 4])
corr_df_spread$Perc_Greensp_Cumulative <- cumsum(corr_df_spread[, 5])

write.csv(corr_df_spread,"corr_df_spread.csv", row.names = FALSE)

```



# Results
## Questions 1-2 (Traits along urb-rural gradient and urban subtransects)
### Model Selection
#### Linear Models
##### Pollinia
###### GLMER
####### City_dist, not Urb_score
```{r}
## trying to check assumptions using glmer vs lm
### No transect yet
# a1 <- glmer(Pollinia_removed ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist, long_Transect_Data_18_19, family = "poisson",
#             glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(a1)
# car::Anova(a1)
# 
# 
# ## add back year
# ## NOT CONVERGING- ERROR
# a2 <- glmer(as.numeric(Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist * as.factor(Year), long_Transect_Data_18_19, family = "poisson",
#             glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(a2)
# par(mfrow=c(2,2))
# plot(a2)
# qqnorm(resid(a2))


########### THESE ARE WHAT I'LL USE ###
## do this for only 2018
# no error
poll_glmer_gradient_01 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist, long_Transect_Data_18, family = "poisson")
summary(poll_glmer_gradient_01)
poll_glmer_gradient_01_anova <- car::Anova(poll_glmer_gradient_01)
# city_dist sig

## do this for only 2019
# no error
poll_glmer_gradient_02 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist, long_Transect_Data_19, family = "poisson")
summary(poll_glmer_gradient_02)
poll_glmer_gradient_02_anova <- car::Anova(poll_glmer_gradient_02)
# city_dist sig

AIC(poll_glmer_gradient_01, poll_glmer_gradient_02)



## add transect
### first make subsets of only urban pops
long_urban <- long_Transect_Data_18_19 %>% filter(Transect_ID != 'Rural')
long_urban_18 <- long_Transect_Data_18 %>% filter(Transect_ID != 'Rural')
long_urban_19 <- long_Transect_Data_19 %>% filter(Transect_ID != 'Rural')

# no warnings!!!!!!!!! USE THIS ###
# full model
poll_glmer_subtr_01 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist * as.factor(Year) * Transect_ID, long_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(poll_glmer_subtr_01)
poll_glmer_subtr_01_anova <- car::Anova(poll_glmer_subtr_01)
AIC(poll_glmer_subtr_01)
# 3-way interxn IS significant

# all two-way interaxns and main effects
poll_glmer_subtr_02 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + as.factor(Year):Transect_ID + City_dist:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(poll_glmer_subtr_02)
poll_glmer_subtr_02_anova <- car::Anova(poll_glmer_subtr_02)
AIC(poll_glmer_subtr_02)
# AIC <2 from first model so continuing backwards model selection

# removing city_dist:transect
poll_glmer_subtr_03 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + as.factor(Year):Transect_ID + City_dist:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(poll_glmer_subtr_03)
poll_glmer_subtr_03_anova <- car::Anova(poll_glmer_subtr_03)
AIC(poll_glmer_subtr_03)
# AIC <2 from first model so continuing backwards model selection


# removing year:transect
poll_glmer_subtr_04 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist:Transect_ID + City_dist:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
poll_glmer_subtr_04_anova <- car::Anova(poll_glmer_subtr_04)
AIC(poll_glmer_subtr_04)
# AIC more than 2 from first model


# removing year:city_dist
poll_glmer_subtr_05 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist:Transect_ID + Transect_ID:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
poll_glmer_subtr_05_anova <- car::Anova(poll_glmer_subtr_05)
AIC(poll_glmer_subtr_05)
# AIC more than 2 from first model


# removing city_dist:transect AND year:transect
poll_glmer_subtr_06 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + City_dist:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
poll_glmer_subtr_06_anova <- car::Anova(poll_glmer_subtr_06)
AIC(poll_glmer_subtr_06)
# AIC more than 2 from first model


# removing city_dist:transect AND year:city_dist
poll_glmer_subtr_07 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + as.factor(Year):Transect_ID + City_dist + as.factor(Year) + Transect_ID, long_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
poll_glmer_subtr_07_anova <- car::Anova(poll_glmer_subtr_07)
AIC(poll_glmer_subtr_07)
# AIC more than 2 from first model


AIC(poll_glmer_subtr_01, # full model- KEEP
    poll_glmer_subtr_02, # all two-way interaxns and main effects- KEEP
    poll_glmer_subtr_03, # all two-way interaxns (EXCEPT city_dist:transect) + main effects- KEEP
    poll_glmer_subtr_04,
    poll_glmer_subtr_05,
    poll_glmer_subtr_06,
    poll_glmer_subtr_07)

poll_glmer_gradient_list <- list(poll_glmer_gradient_01,
                                 poll_glmer_gradient_02)

poll_glmer_subtr_list <- list(poll_glmer_subtr_01, 
    poll_glmer_subtr_02, 
    poll_glmer_subtr_03, 
    poll_glmer_subtr_04,
    poll_glmer_subtr_05,
    poll_glmer_subtr_06,
    poll_glmer_subtr_07)

i<-0
sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_pollen_citydist.csv')
for (x in poll_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in poll_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
sink()
i<-0


```

####### Urb_score, not city_dist
```{r}
## No transect yet
u_poll_glmer_gradient_1 <- glmer(Pollinia_removed ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score * as.factor(Year), urb_scores_poll_long, family = "poisson",
             glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_poll_glmer_gradient_1)
u_poll_glmer_gradient_1_anova <- car::Anova(u_poll_glmer_gradient_1)
# interaction and main effects sig

u_poll_glmer_gradient_1.1 <- glmer(Pollinia_removed ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score + as.factor(Year), urb_scores_poll_long, family = "poisson",
             glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_poll_glmer_gradient_1.1)
car::Anova(u_poll_glmer_gradient_1.1)

AIC(u_poll_glmer_gradient_1, u_poll_glmer_gradient_1.1)



## add transect
# FULL MODEL
u_poll_glmer_subtr_1 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score * as.factor(Year) *Transect_ID, urb_scores_poll_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_poll_glmer_subtr_1)
u_poll_glmer_subtr_1_anova <- car::Anova(u_poll_glmer_subtr_1)
AIC(u_poll_glmer_subtr_1)
# 3-way interxn IS significant

# looking at full model minus 3-way interaxn
u_poll_glmer_subtr_1.1 <- glmer((Pollinia_removed) ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score:as.factor(Year) + Urb_score:Transect_ID + Transect_ID:as.factor(Year) + as.factor(Year) + Transect_ID + Urb_score, urb_scores_poll_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_poll_glmer_subtr_1.1_anova <- car::Anova(u_poll_glmer_subtr_1.1)
AIC(u_poll_glmer_subtr_1.1)
# >2 AIC from full model




u_poll_glmer_gradient_list <- list(u_poll_glmer_gradient_1,
                                 u_poll_glmer_gradient_1.1)

u_poll_glmer_subtr_list <- list(u_poll_glmer_subtr_1, 
    u_poll_glmer_subtr_1.1)


i<-0
sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_pollen_urbscore.csv')
for (x in u_poll_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in u_poll_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```


###### LM
####### Without transect- NO TRANSFORMATION NEEDED
######## Diagnostics
######### City_dist: NO TRANSFORMATION NEEDED
```{r}
# POLLINIA
AvgVars_notNA_Poll_18_19 <- rbind(AvgVars_notNA_Poll_18, AvgVars_notNA_Poll_19)


# old model-checking code: using lm
allpoll_lm <- lm(Average_Pollinia ~ City_dist * Year, data = AvgVars_notNA_Poll_18_19)

par(mfrow=c(2,2))
plot(allpoll_lm)
summary(allpoll_lm)

ggqqplot(AvgVars_notNA_Poll_18_19$Average_Pollinia)
## Almost all data points fall within the envelope but some don't.

# Histogram
gg_reshist(allpoll_lm, bins=20)

# # Shapiro-Wilk normality test
# shapiro.test(AvgVars_notNA_Poll_18_19$Average_Pollinia)
# ## From the output, the p-value < 0.05 implying that the distribution of the data are significantly different from normal distribution. We cannot assume the normality.

# DATA LOOKS NORMAL ENOUGH.

```

######### Urb_score: NO TRANSFORMATION NEEDED
```{r}
# POLLINIA
diag_urb_poll_1 <- lm(Average_Pollinia ~ Urb_score * Year, data = urb_scores_poll_all)

par(mfrow=c(2,2))
plot(diag_urb_poll_1)
summary(diag_urb_poll_1)
ggqqplot(urb_scores_poll_all$Average_Pollinia)
## Almost all data points fall within the envelope but some don't.

# Histogram
gg_reshist(diag_urb_poll_1, bins=20)

# DATA LOOKS NORMAL ENOUGH.

```


######## ANOVA
######### City_dist, not urb_score
```{r}
lm.poll.gr.1 <- lm(Average_Pollinia 	~ Year * City_dist, data = AvgVars_notNA_Poll_18_19)
lm.poll.gr.1_anova <- car::Anova(lm.poll.gr.1, REML = F)
summary(lm.poll.gr.1)
# Interaction not significant but main effects are.

lm.poll.gr.2 <- lm(Average_Pollinia 	~ Year + City_dist, data = AvgVars_notNA_Poll_18_19)
lm.poll.gr.2_anova <- car::Anova(lm.poll.gr.2, REML = F)
# Interaction not significant but main effects are.

AIC(lm.poll.gr.1, lm.poll.gr.2)
```

######### urb_score
```{r}
u_poll_glm_gradient_1 <- lm(Average_Pollinia 	~ Year * Urb_score, data = urb_scores_poll_all)
u_poll_glm_gradient_1_anova <- car::Anova(u_poll_glm_gradient_1, REML = F)
summary(u_poll_glm_gradient_1, REML = F)
# Interaction not significant but main effects are.

u_poll_glm_gradient_2 <- lm(Average_Pollinia 	~ Year + Urb_score, data = urb_scores_poll_all)
u_poll_glm_gradient_2_anova <- car::Anova(u_poll_glm_gradient_2, REML = F)
# Year and urb_score sig.

AIC(u_poll_glm_gradient_1, u_poll_glm_gradient_2)

```

####### With transect- NO TRANSFORMATION NEEDED
######## Diagnostics
######### City_dist: NO TRANSFORMATION NEEDED
```{r}
AvgVars_notNA_Poll_18_19_urban <-subset(AvgVars_notNA_Poll_18_19, Transect_ID == "North" | Transect_ID == "South")

urbpoll_lm <- lm(Average_Pollinia ~ City_dist * as.factor(Year) * Transect_ID, data = AvgVars_notNA_Poll_18_19_urban)

par(mfrow=c(2,2))
plot(urbpoll_lm)
summary(urbpoll_lm)

ggqqplot(AvgVars_notNA_Poll_18_19_urban$Average_Pollinia)
## Almost all data points fall within the envelope but some don't.

# Histogram
gg_reshist(urbpoll_lm, bins=20)

 #looks normal!

```

######### Urb_score: NO TRANSFORMATION NEEDED
```{r}

diag_urb_poll_1 <- lm(Average_Pollinia ~ Urb_score * as.factor(Year) * Transect_ID, data = urb_scores_poll)

par(mfrow=c(2,2))
plot(diag_urb_poll_1)
summary(diag_urb_poll_1)

ggqqplot(urb_scores_poll$Average_Pollinia)
## Nearly all data points fall within the envelope

# Histogram
gg_reshist(diag_urb_poll_1, bins=20)

 #looks normal!

```


######## ANOVA
######### City_dist, not urb_index
```{r}
lm.poll.subt.1 <- lm(Average_Pollinia 	~ Year * City_dist * Transect_ID, data = AvgVars_notNA_Poll_18_19_urban)
car::Anova(lm.poll.subt.1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

lm.poll.subt.2 <- lm(Average_Pollinia 	~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID, data = AvgVars_notNA_Poll_18_19_urban)
lm.poll.subt.2_anova <- car::Anova(lm.poll.subt.2, REML = F)
# Year:transect interaction is marginally sig but year:citydist and citydist:transect aren't, so I'll remove those

lm.poll.subt.3 <- (lm(Average_Pollinia 	~ Year + City_dist + Transect_ID + Year:Transect_ID, data = AvgVars_notNA_Poll_18_19_urban))
lm.poll.subt.3_anova <- car::Anova(lm.poll.subt.3, REML = F)

lm.poll.subt.4 <- (lm(Average_Pollinia 	~ Year + City_dist + Transect_ID, data = AvgVars_notNA_Poll_18_19_urban))
lm.poll.subt.4_anova <- car::Anova(lm.poll.subt.4, REML = F)

AIC(lm.poll.subt.1, lm.poll.subt.2, lm.poll.subt.3, lm.poll.subt.4)
```


######### Urb_index, not city_dist
```{r}
u_poll_glm_subtr_1 <- lm(Average_Pollinia 	~ Year * Urb_score * Transect_ID, data = urb_scores_poll)
u_poll_glm_subtr_1_anova <- car::Anova(u_poll_glm_subtr_1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

u_poll_glm_subtr_2 <- lm(Average_Pollinia 	~ Year + Urb_score + Transect_ID + Year:Urb_score + Year:Transect_ID + Urb_score:Transect_ID, data = urb_scores_poll)
u_poll_glm_subtr_2_anova <- car::Anova(u_poll_glm_subtr_2, REML = F)
# Year:transect interaction is sig but year:Urb_score and Urb_score:transect aren't, so I'll remove those

u_poll_glm_subtr_3 <- lm(Average_Pollinia 	~ Year + Urb_score + Transect_ID + Year:Transect_ID, data = urb_scores_poll)
u_poll_glm_subtr_3_anova <- car::Anova(u_poll_glm_subtr_3, REML = F)
# Urb_score not significant alone but going to keep it since it's central to my question. I'll remove the year:transect itneraxn though since I don't really care about year.


u_poll_glm_subtr_4 <- lm(Average_Pollinia 	~ Year + Urb_score + Transect_ID, data = urb_scores_poll)
u_poll_glm_subtr_4_anova <- car::Anova(u_poll_glm_subtr_4, REML = F)
# Year sig, transect marg sig


AIC(u_poll_glm_subtr_1, u_poll_glm_subtr_2, u_poll_glm_subtr_3, u_poll_glm_subtr_4)
# only 2 and 3 are top models

```



###### inflor/plant-level means
The point of this is to test whether the complicated glmer model is better than the simple lmer. Additionally, is the lm better than lmer? The simpler model will make the regression results easier to interpret if, in fact, the simplest model provides the same conclusions/results as the most complicated.
The lm uses population-level means while lmer and glmer use flower-level, nested data.
```{r}
# Make new dfs with hierarchical means
## make new df w/inflor-level means
long_inflor_means <- long_Transect_Data_18_19 %>% group_by(Patch_ID, Year, Pop_ID, Plant_Num, Inflor) %>%
    dplyr::summarise(
      Poll_rm_per_inflor=mean(Pollinia_removed,na.rm = TRUE),
      City_dist=mean(City_dist),
      Transect_ID=first(Transect_ID),
      Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
      nPlants=n()
      )

## make new df w/plant-level means
long_plant_means <- long_inflor_means %>% group_by(Patch_ID, Year, Pop_ID, Plant_Num) %>%
    dplyr::summarise(
      Poll_rm_per_plant=mean(Poll_rm_per_inflor,na.rm = TRUE),
      City_dist=mean(City_dist),
      Transect_ID=first(Transect_ID),
      Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
      nPlants=n()
      )

# xxxxx <- long_Transect_Data_18_19 %>%
#   group_by(Patch_ID, Year, Pop_ID, Plant_Num, Inflor) %>%
#   dplyr::summarise(
#       flowers_surveyed=n_distinct(Pollinia_removed,na.rm = TRUE))
# 
# xxxxx <- xxxxx %>% group_by(Patch_ID, Year, Pop_ID) %>%
#     dplyr::summarise(
#       flowers_surveyed=sum(flowers_surveyed,na.rm = TRUE))

test <- long_Transect_Data_18_19 %>%
  group_by(Patch_ID, Year, Pop_ID, Plant_Num, Inflor) %>%
  dplyr::summarise(
      flowers_surveyed=n_distinct(Pollinia_removed,na.rm = TRUE)) %>%
  group_by(Patch_ID, Year, Pop_ID) %>%
    dplyr::summarise(
      flowers_surveyed=sum(flowers_surveyed,na.rm = TRUE))

hist(test$flowers_surveyed, breaks = 15)

# try out new lmers
###### INFLORESCENCE MEANS ########
######### GRADIENT
z1 <- lmer(Poll_rm_per_inflor ~ (1|Patch_ID/Plant_Num) * City_dist * as.factor(Year), long_inflor_means, REML = F)
summary(z1)
car::Anova(z1)
# interxn not sig but main effects are
z1.1 <- car::Anova(lmer(Poll_rm_per_inflor ~ (1|Patch_ID/Plant_Num) + City_dist + as.factor(Year), long_inflor_means, REML = F))
# Year and city_dist sig-
# **SAME "STORY" as anova w/pop means for lm**

###### INFLORESCENCE MEANS ########
######### urban transects
z2 <- lmer(Poll_rm_per_inflor ~ (1|Patch_ID/Plant_Num) + City_dist * as.factor(Year) * Transect_ID, (long_inflor_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z2)
z2.1 <- car::Anova(z2)
# **SAME "STORY" as anova w/pop means for lmer in that same vars are sig, but slightly less so than anova w/pop means; 3-way interaxn marginally sig whereas other was < 0.05**


###### PLANT MEANS ########
######### GRADIENT
z3 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID) + City_dist * as.factor(Year), long_plant_means, REML = F)
summary(z3)
car::Anova(z3)
# interxn not sig but main effects are

z3.1 <- car::Anova(lmer(Poll_rm_per_plant ~ (1|Patch_ID) + City_dist + as.factor(Year), long_plant_means, REML = F))
# SAME "STORY" as anova w/pop means 


###### PLANT MEANS ########
######### urban transects
z4 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, (long_plant_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z4 )
car::Anova(z4 )
# 3-way interaxn not sig, so removing

z4.1 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID) + City_dist:as.factor(Year) + City_dist:Transect_ID + Transect_ID:as.factor(Year) + Transect_ID + City_dist + as.factor(Year), (long_plant_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z4.1)
car::Anova(z4.1)

z4.2 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID) + City_dist:as.factor(Year) + Transect_ID:as.factor(Year) + Transect_ID + City_dist + as.factor(Year), (long_plant_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z4.2)
z4.22 <- car::Anova(z4.2)
## Year:Transect+ID and City_dist:Year both marginally sig, so this is the best model unless want to make p = 0.05 strict cutoff

# Making p = 0.05 the strict cutoff...
z4.3 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID) + Transect_ID + City_dist + as.factor(Year), (long_plant_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z4.3)
car::Anova(z4.3)
## Only Year is significant

z4.4 <- lmer(Poll_rm_per_plant ~ (1|Patch_ID)+ as.factor(Year), (long_plant_means %>% filter(Transect_ID != 'Rural')), REML = F)
summary(z4.4)
z4.5 <- car::Anova(z4.4)
# Year is significant

# THIS 'STORY' DIFFERS FROM ANOVA W/POP MEANS.
```

##### Pods
###### plant-level means
The point of this is to test whether the complicated glmer model is better than the simple lmer. Additionally, is the lm better than lmer? The simpler model will make the regression results easier to interpret if, in fact, the simplest model provides the same conclusions/results as the most complicated.
The lm uses population-level means while lmer and glmer use plant-level data.
```{r}
# Make new dfs with hierarchical means
## make new df w/plant-level means
### this is the same as Transect_Data_18_19!
long_plant_means_pods <- fertile_long %>% group_by(Patch_ID, Year, Pop_ID, Plant_Num) %>%
    dplyr::summarise(
      Pods_per_plant=mean(Viable_Pods,na.rm = TRUE),
      City_dist=mean(City_dist),
      Transect_ID=first(Transect_ID),
      Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
      nPlants=n()
      )

# try out new glmer
## GRADIENT
y1 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year), long_plant_means_pods, family = "poisson")
summary(y1)
car::Anova(y1)
# Year marg sig but interaxn isn't, so removing that

y1.1 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year), long_plant_means_pods, family = "poisson")
summary(y1.1)
car::Anova(y1.1)
# Year marg sig. Removing city_dist

y1.2 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + as.factor(Year), long_plant_means_pods, family = "poisson")
summary(y1.2)
y1.21 <- car::Anova(y1.2)
# Year marg sig


## URBAN SUBTRANSECTS
y2 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(y2)
y2.1 <- car::Anova(y2)
# 3-way interaxn is significant here


```

###### LM
####### Without transect -USE SQRT TRANSFORMATION
######## Diagnostics
######### City_dist: USE SQRT TRANSFORMATION
```{r}

allpod_lm <- lm(Viable_Pods ~ City_dist * Year , data = fertile_pops_all_notNApods)

par(mfrow=c(2,2))
plot(allpod_lm)
summary(allpod_lm)

qplot(fertile_pops_all_notNApods$Viable_Pods)
#looks like 15 may be an outlier that could be removed

summary(fertile_pops_all_notNApods$Viable_Pods)
sd(fertile_pops_all_notNApods$Viable_Pods)
# so, planst with 12 and 15 pods are (12-3.89)/2.6 = 3.11 and (15-3.89)/2.6 = 4.27 standard deviations from the mean, respectively

gg_reshist(lm((Viable_Pods) ~ City_dist * Year, data = fertile_pops_all_notNApods), bins=20)
ggqqplot(fertile_pops_all_notNApods$Viable_Pods)
## Most data points fall within the envelope but some don't. (towards one end)



# try  transformations
gg_reshist(lm((Viable_Pods)^(1/2) ~ City_dist * Year, data = fertile_pops_all_notNApods), bins=20)
plot(lm((Viable_Pods)^(1/2) ~ City_dist * Year , data = fertile_pops_all_notNApods))
ggqqplot((fertile_pops_all_notNApods$Viable_Pods)^(1/2))
shapiro.test((fertile_pops_all_notNApods$Viable_Pods)^(1/2))
##### GOING WITH THIS ONE. LOOKS GOOD.

# gg_reshist(lm((Viable_Pods)^(1/3) ~ City_dist * Year, data = fertile_pops_all_notNApods), bins=20)
# plot(lm((Viable_Pods)^(1/3) ~ City_dist * Year, data = fertile_pops_all_notNApods))
# ggqqplot((fertile_pops_all_notNApods$Viable_Pods)^(1/3))
# shapiro.test((fertile_pops_all_notNApods$Viable_Pods)^(1/3))
# 
# gg_reshist(lm(log(Viable_Pods + 1) ~ City_dist * Year, data = fertile_pops_all_notNApods), bins=20)
# plot(lm(log(Viable_Pods + 1) ~ City_dist * Year, data = fertile_pops_all_notNApods))
# ggqqplot(log(fertile_pops_all_notNApods$Viable_Pods + 1))
# shapiro.test(log(fertile_pops_all_notNApods$Viable_Pods + 1))


### NOT USING THIS ANYMORE
# add log(pods) col to df
# fertile_pops_all_notNApods$Viable_Pods_log <- log(fertile_pops_all_notNApods$Viable_Pods +1)


# add sqrt(pods) col to df
fertile_pops_all_notNApods$Viable_Pods_sqrt <- sqrt(fertile_pops_all_notNApods$Viable_Pods)
```

######### Urb_score: USE SQRT TRANSFORMATION
```{r}

diag_urb_pods_1 <- lm(Viable_Pods ~ Urb_score * Year , data = urb_scores_pods_all)

par(mfrow=c(2,2))
plot(diag_urb_pods_1)
summary(diag_urb_pods_1)

gg_reshist(diag_urb_pods_1, bins=20)
#looks like 98 & 76 may be outliers

summary(urb_scores_pods_all$Viable_Pods)
sd(urb_scores_pods_all$Viable_Pods)
# so, planst with 12 and 15 pods are (12-3.89)/2.6 = 3.11 and (15-3.89)/2.6 = 4.27 standard deviations from the mean, respectively

ggqqplot(urb_scores_pods_all$Viable_Pods)
## Most data points fall within the envelope but some don't. (towards one end)



# try  transformations
gg_reshist(lm((Viable_Pods)^(1/2) ~ Urb_score * Year, data = urb_scores_pods_all), bins=20)
plot(lm((Viable_Pods)^(1/2) ~ Urb_score * Year , data = urb_scores_pods_all))
ggqqplot((urb_scores_pods_all$Viable_Pods)^(1/2))
shapiro.test((urb_scores_pods_all$Viable_Pods)^(1/2))
##### GOING WITH THIS ONE. LOOKS GOOD.


# add sqrt(pods) col to df
urb_scores_pods_all$Viable_Pods_sqrt <- sqrt(urb_scores_pods_all$Viable_Pods)
```


######## ANOVA
######### City_dist, not urb_score
```{r}
# ANOVA
lm.pods.gr.1 <- lm(Viable_Pods_sqrt ~ Year * City_dist, data = fertile_pops_all_notNApods)
lm.pods.gr.1_anova <- car::Anova((lm.pods.gr.1), REML = F)
# Interaction and both main effects not significant.

lm.pods.gr.2 <- lm(Viable_Pods_sqrt ~ Year + City_dist, data = fertile_pops_all_notNApods)
lm.pods.gr.2_anova <- car::Anova((lm.pods.gr.2), REML = F)
# both main effects not significant.

AIC(lm.pods.gr.1, lm.pods.gr.2)

```

######### urb_score
```{r}
u_pod_glm_gradient_1 <- lm(Viable_Pods_sqrt 	~ Year * Urb_score, data = urb_scores_pods_all)
u_pod_glm_gradient_1_anova <- car::Anova(u_pod_glm_gradient_1, REML = F)
# Interaction and both main effects not significant.

u_pod_glm_gradient_2 <- lm(Viable_Pods_sqrt 	~ Year + Urb_score, data = urb_scores_pods_all)
u_pod_glm_gradient_2_anova <- car::Anova(u_pod_glm_gradient_2, REML = F)
# both main effects not significant.

AIC(u_pod_glm_gradient_1, u_pod_glm_gradient_2)
```


####### With transect- USE SQRT TRANSFORMATION
######## Diagnostics
######### City_dist: USE SQRT TRANSFORMATION
```{r}
fertile_pops_all_notNApods_urban <-subset(fertile_pops_all_notNApods, Transect_ID == "North" | Transect_ID == "South")

urbpods_lm <- lm(Viable_Pods ~ City_dist * Year * Transect_ID, data = fertile_pops_all_notNApods_urban)

par(mfrow=c(2,2))
plot(urbpods_lm)
# FANNING EFFECT IN RESIDS VS. FITTED PLOT- Heteroscedastic
library(lmtest)
bptest(urbpods_lm)
# high p-value (0.31) indicates homoscedasticity... so maybe it's ok?
ncvTest(urbpods_lm)
# low p-value (0.001) indicates heteroscedasticity... so maybe it's not ok?

summary(urbpods_lm)
summary(fertile_pops_all_notNApods_urban$Viable_Pods)
sd(fertile_pops_all_notNApods_urban$Viable_Pods)

qplot(fertile_pops_all_notNApods_urban$Viable_Pods)

ggqqplot(fertile_pops_all_notNApods_urban$Viable_Pods)
## Almost all data points fall within the envelope but some along one end don't.

# Histogram
gg_reshist(urbpods_lm, bins=20)


# try log transformation
gg_reshist(lm(log(Viable_Pods+1) ~ City_dist * Transect_ID * Year, data = fertile_pops_all_notNApods_urban), bins=20)
par(mfrow=c(2,2))
plot(lm(log(Viable_Pods+1) ~ City_dist* Transect_ID * Year, data = fertile_pops_all_notNApods_urban))
summary(lm(log(Viable_Pods+1) ~ City_dist* Transect_ID * Year, data = fertile_pops_all_notNApods_urban))
ggqqplot(log(fertile_pops_all_notNApods_urban$Viable_Pods+1))
shapiro.test(log(fertile_pops_all_notNApods_urban$Viable_Pods+1))
# still not good (too strong?)


# try sq rt & cube root
gg_reshist(lm(Viable_Pods^(1/2) ~ City_dist * Transect_ID * Year, data = fertile_pops_all_notNApods_urban), bins=20)
plot(lm(Viable_Pods^(1/2) ~ City_dist * Transect_ID * Year, data = fertile_pops_all_notNApods_urban))
summary(lm(Viable_Pods^(1/2) ~ City_dist * Transect_ID * Year, data = fertile_pops_all_notNApods_urban))

par(mfrow=c(2,2))
plot(lm(Viable_Pods^(1/2) ~ City_dist, fertile_pops_all_notNApods_urban))
ggqqplot(fertile_pops_all_notNApods_urban$Viable_Pods^(1/2))
shapiro.test(fertile_pops_all_notNApods_urban$Viable_Pods^(1/2))
# still not great but better than log & cube root. going with sq rt

# add sqrt(pods) col to df
fertile_pops_all_notNApods_urban$Viable_Pods_sqrt <- sqrt(fertile_pops_all_notNApods_urban$Viable_Pods)
```


######### Urb_score: USE SQRT TRANSFORMATION
```{r}

diag_urb_pods_2 <- lm(Viable_Pods ~ Urb_score * Year * Transect_ID, data = urb_scores_pods)

par(mfrow=c(2,2))
plot(diag_urb_pods_2)
# FANNING EFFECT IN RESIDS VS. FITTED PLOT- Heteroscedastic
library(lmtest)
bptest(diag_urb_pods_2)
# high p-value (0.23) indicates homoscedasticity... so maybe it's ok?
ncvTest(diag_urb_pods_2)
# low p-value (0.003) indicates heteroscedasticity... so maybe it's not ok?

summary(diag_urb_pods_2)
summary(urb_scores_pods$Viable_Pods)
sd(urb_scores_pods$Viable_Pods)

gg_reshist(diag_urb_pods_2, bins = 20)

ggqqplot(urb_scores_pods$Viable_Pods)
## Almost all data points fall within the envelope but some along one end don't


# try log transformation
gg_reshist(lm(log(Viable_Pods+1) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods), bins=20)
par(mfrow=c(2,2))
plot(lm(log(Viable_Pods+1) ~ Urb_score* Transect_ID * Year, data = urb_scores_pods))
summary(lm(log(Viable_Pods+1) ~ Urb_score* Transect_ID * Year, data = urb_scores_pods))
ggqqplot(log(urb_scores_pods$Viable_Pods+1))
shapiro.test(log(urb_scores_pods$Viable_Pods+1))
# still not good (too strong?)


# try sq rt
gg_reshist(lm(Viable_Pods^(1/2) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods), bins=20)
plot(lm(Viable_Pods^(1/2) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods))
summary(lm(Viable_Pods^(1/2) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods))
ggqqplot(urb_scores_pods$Viable_Pods^(1/2))
shapiro.test(urb_scores_pods$Viable_Pods^(1/2))


# try cube root
gg_reshist(lm(Viable_Pods^(1/3) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods), bins=20)
plot(lm(Viable_Pods^(1/3) ~ Urb_score * Transect_ID * Year, data = urb_scores_pods))
ggqqplot(urb_scores_pods$Viable_Pods^(1/3))
shapiro.test(urb_scores_pods$Viable_Pods^(1/3))
# still not great but better than log & cube root. going with sq rt

# add sqrt(pods) col to df
urb_scores_pods$Viable_Pods_sqrt <- sqrt(urb_scores_pods$Viable_Pods)

```

######## ANOVA
######### City_dist, not urb_scores
```{r}
lm.pods.subt.1 <- lm(Viable_Pods_sqrt ~ Year * City_dist * Transect_ID, data = fertile_pops_all_notNApods_urban)
lm.pods.subt.1_anova <- car::Anova(lm.pods.subt.1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

lm.pods.subt.2 <- lm(Viable_Pods_sqrt 	~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID, data = fertile_pops_all_notNApods_urban)
lm.pods.subt.2_anova <- car::Anova(lm.pods.subt.2, REML = F)
# Nothing significant

lm.pods.subt.3 <- lm(Viable_Pods_sqrt 	~ Year + City_dist + Transect_ID, data = fertile_pops_all_notNApods_urban)
lm.pods.subt.3_anova <- car::Anova(lm.pods.subt.3, REML = F)
# Nothing significant

AIC(lm.pods.subt.1, lm.pods.subt.2, lm.pods.subt.3)
```

######### urb_scores, not city_dist
```{r}
u_pod_glm_subtr_1 <- lm(Viable_Pods_sqrt 	~ Year * Urb_score * Transect_ID, data = urb_scores_pods)
u_pod_glm_subtr_1_anova <- car::Anova(u_pod_glm_subtr_1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

u_pod_glm_subtr_2 <- lm(Viable_Pods_sqrt 	~ Year + Urb_score + Transect_ID + Year:Urb_score + Year:Transect_ID + Urb_score:Transect_ID, data = urb_scores_pods)
u_pod_glm_subtr_2_anova <- car::Anova(u_pod_glm_subtr_2, REML = F)
# Nothing significant

u_pod_glm_subtr_3 <- lm(Viable_Pods_sqrt 	~ Year + Urb_score + Transect_ID, data = urb_scores_pods)
u_pod_glm_subtr_3_anova <- car::Anova(u_pod_glm_subtr_3, REML = F)
# nothing sig

AIC(u_pod_glm_subtr_1, u_pod_glm_subtr_2, u_pod_glm_subtr_3)
```


###### GLMER
####### City-dist, not urb_score
```{r}
### No transect yet
pods_glmer_gradient_01 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + City_dist * as.factor(Year), fertile, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(pods_glmer_gradient_01)
pods_glmer_gradient_01_anova <- car::Anova(pods_glmer_gradient_01)
# nothing sig

pods_glmer_gradient_02 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + City_dist + as.factor(Year), fertile, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(pods_glmer_gradient_02)
pods_glmer_gradient_02_anova <- car::Anova(pods_glmer_gradient_02)
# nothing sig

AIC(pods_glmer_gradient_01, pods_glmer_gradient_02)




## add transect
# first, make urban subsets
# fertile_urban <- fertile_long %>% filter(Transect_ID != 'Rural')
# fertile_urban_18 <- fertile_urban %>% filter(Transect_ID != 'Rural')
# fertile_urban_19 <- fertile_urban %>% filter(Transect_ID != 'Rural')

# Transect_Data_18_19_urban <- Transect_Data_18_19 %>% filter(Transect_ID != 'Rural')


# full model
pods_glmer_subtr_01 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(pods_glmer_subtr_01)
pods_glmer_subtr_01_anova <- car::Anova(pods_glmer_subtr_01)
AIC(pods_glmer_subtr_01)
# 3-way interaxn sig, plus two other 2-way interaxns


# full model minus 3-way interaxn
pods_glmer_subtr_02 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + City_dist:Transect_ID + City_dist:as.factor(Year) + as.factor(Year):Transect_ID + City_dist + as.factor(Year) + Transect_ID, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(pods_glmer_subtr_02)
pods_glmer_subtr_02_anova <- car::Anova(pods_glmer_subtr_02)
AIC(pods_glmer_subtr_02)
# AIC >2 away from full model so stopping






pods_glmer_gradient_list <- list(pods_glmer_gradient_01,
                                 pods_glmer_gradient_02)

pods_glmer_subtr_list <- list(pods_glmer_subtr_01,
                              pods_glmer_subtr_02)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_pods_citydist.csv')
i<-0
for (x in pods_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in pods_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```

####### urb_score, not dist
```{r}
### No transect yet
u_pods_glmer_gradient_1 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score * as.factor(Year), urb_scores_pods_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_pods_glmer_gradient_1)
u_pods_glmer_gradient_1_anova <- car::Anova(u_pods_glmer_gradient_1)
# only urb_score marg sig

u_pods_glmer_gradient_1.1 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year), urb_scores_pods_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_pods_glmer_gradient_1.1)
u_pods_glmer_gradient_1.1_anova <- car::Anova(u_pods_glmer_gradient_1.1)
# only urb_score marg sig

AIC(u_pods_glmer_gradient_1,u_pods_glmer_gradient_1.1)




## add transect
# full model
u_pods_glmer_subtr_1 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score * as.factor(Year) * Transect_ID, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_pods_glmer_subtr_1)
u_pods_glmer_subtr_1_anova <- car::Anova(u_pods_glmer_subtr_1)
AIC(u_pods_glmer_subtr_1)
# 3-way interaxn not sig, but one 2-way interaxn is

# full model minus 3-way interaxn
u_pods_glmer_subtr_1.1 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:as.factor(Year) + Urb_score:Transect_ID + as.factor(Year):Transect_ID, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_pods_glmer_subtr_1.1)
u_pods_glmer_subtr_1.1_anova <- car::Anova(u_pods_glmer_subtr_1.1)
AIC(u_pods_glmer_subtr_1.1)
# <2 AIC from full model, so moving on

# full model minus 3-way interaxn and urbscore:year
u_pods_glmer_subtr_1.2 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Transect_ID + Transect_ID:Urb_score, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(u_pods_glmer_subtr_1.2)
u_pods_glmer_subtr_1.2_anova <- car::Anova(u_pods_glmer_subtr_1.2)
AIC(u_pods_glmer_subtr_1.2)
# lower AIC than full model

# full model minus 3-way interaxn and transect:year
u_pods_glmer_subtr_1.3 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Urb_score + Transect_ID:Urb_score, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.3_anova <- car::Anova(u_pods_glmer_subtr_1.3)
AIC(u_pods_glmer_subtr_1.3)
# AIC >2 than full model


# full model minus 3-way interaxn and transect:urb_score
u_pods_glmer_subtr_1.4 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Urb_score + Transect_ID:as.factor(Year), urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.4_anova <- car::Anova(u_pods_glmer_subtr_1.4)
AIC(u_pods_glmer_subtr_1.4)
# AIC >2 than full model

AIC(u_pods_glmer_subtr_1,
    u_pods_glmer_subtr_1.1,
    u_pods_glmer_subtr_1.2,
    u_pods_glmer_subtr_1.3,
    u_pods_glmer_subtr_1.4)
# keep doing backwards selection


# main effects plus year:urb_score
u_pods_glmer_subtr_1.5 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Urb_score, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.5_anova <- car::Anova(u_pods_glmer_subtr_1.5)
AIC(u_pods_glmer_subtr_1.5)
# AIC >2 than full model

# main effects plus transect:urb_score
u_pods_glmer_subtr_1.6 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Transect_ID:Urb_score, urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.6_anova <- car::Anova(u_pods_glmer_subtr_1.6)
AIC(u_pods_glmer_subtr_1.6)
# AIC >2 than full model

# main effects plus transect:year
u_pods_glmer_subtr_1.7 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Transect_ID:as.factor(Year), urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.7_anova <- car::Anova(u_pods_glmer_subtr_1.7)
AIC(u_pods_glmer_subtr_1.7)
# AIC <2 from full model... continuing backwards selection

# main effects only
u_pods_glmer_subtr_1.8 <- glmer(as.numeric(Viable_Pods) ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID , urb_scores_pods_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_pods_glmer_subtr_1.8_anova <- car::Anova(u_pods_glmer_subtr_1.8)
AIC(u_pods_glmer_subtr_1.8)
# AIC >>2 from full model


u_pods_glmer_gradient_list <- list(u_pods_glmer_gradient_1,
                                   u_pods_glmer_gradient_1.1)

u_pods_glmer_subtr_list <- list(u_pods_glmer_subtr_1,
                                u_pods_glmer_subtr_1.1,
                                u_pods_glmer_subtr_1.2,
                                u_pods_glmer_subtr_1.3,
                                u_pods_glmer_subtr_1.4,
                                u_pods_glmer_subtr_1.5,
                                u_pods_glmer_subtr_1.6,
                                u_pods_glmer_subtr_1.7,
                                u_pods_glmer_subtr_1.8)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_pods_urbscore.csv')
i<-0
for (x in u_pods_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in u_pods_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```

##### Peduncles
###### plant-level means
The point of this is to test whether the complicated glmer model is better than the simple lmer. Additionally, is the lm better than lmer? The simpler model will make the regression results easier to interpret if, in fact, the simplest model provides the same conclusions/results as the most complicated.
The lm uses population-level means while lmer and glmer use plant-level data.
```{r}
# Make new dfs with hierarchical means
## make new df w/plant-level means
long_plant_means_peds <- fertile_long %>% group_by(Patch_ID, Year, Pop_ID, Plant_Num) %>%
    dplyr::summarise(
      Peds_per_plant=mean(Peduncles,na.rm = TRUE),
      City_dist=mean(City_dist),
      Transect_ID=first(Transect_ID),
      Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
      nPlants=n()
      )

# try out new glmer
x1 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year), long_plant_means_peds, family = "poisson")
summary(x1)
x1.1 <- car::Anova(x1)
# City_dist:Year interaxn sig, main effects aren't


# try out new glmer w/transects
x2 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2)
car::Anova(x2)
# 3-way interaxn not sig- trying secondary interaxns


# x2.1 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:City_dist + Transect_ID:as.factor(Year) + City_dist:as.factor(Year), (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson", 
#             glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(x2.1)
# car::Anova(x2.1)
##### NOT CONVERGING. TRYING SEPARATE MAIN EFFECTS

# Remove 2-way interactions one by one to see if any are sig- NONE WERE.
## Removed City_dist:Year
x2.2 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:City_dist + Transect_ID:as.factor(Year), (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson", 
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2.2)
car::Anova(x2.2)
## No 2-way interaxn sig

# Removed Transect_ID:Year
x2.3 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:City_dist + City_dist:as.factor(Year), (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson", 
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2.3)
car::Anova(x2.3)
## No 2-way interaxn sig

# Removed Transect_ID:City_dist
x2.4 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + as.factor(Year):City_dist + Transect_ID:as.factor(Year), (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson", 
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2.4)
car::Anova(x2.4)
## No 2-way interaxn sig


x2.5 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID, (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2.5)
car::Anova(x2.5)
# City_dist sig


x2.6 <- glmer(as.numeric(Peds_per_plant) ~ (1|Patch_ID) + City_dist, (long_plant_means_peds %>% filter(Transect_ID != 'Rural')), family = "poisson", 
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(x2.6)
x2.61 <- car::Anova(x2.6)
# City_dist sig
```

###### LM
####### Without transect- USE SQUARING TRANSFORMATION
######## Diagnostics
######### City_dist: USE SQUARING TRANSFORMATION
```{r}

fertile_pops_all_notNApeds <- fertile_pops_all[!is.na(fertile_pops_all$Peduncles),]

allped_lm <- lm(Peduncles ~ City_dist * Year, data = fertile_pops_all_notNApeds)

par(mfrow=c(2,2))
plot(allped_lm)
summary(allped_lm)

## Histogram
gg_reshist(allped_lm, bins=20)

qplot(fertile_pops_all_notNApeds$Peduncles, bins = 15)

summary(fertile_pops_all_notNApeds$Peduncles)
sd(fertile_pops_all_notNApeds$Peduncles)

ggqqplot(fertile_pops_all_notNApeds$Peduncles)
## Most data points fall within the envelope but several don't. (towards one end)

# Shapiro-Wilk normality test
shapiro.test(fertile_pops_all_notNApeds$Peduncles)
## From the output, the p-value < 0.05 implying that the distribution of the data are significantly different from normal distribution. We cannot assume the normality.
# looks left-skewed.

qplot((fertile_pops_all_notNApeds$Peduncles)^2, bins = 20)
plot(lm((Peduncles^2) ~ City_dist, data = fertile_pops_all_notNApeds), bins=20)
gg_reshist(lm((Peduncles^2) ~ City_dist, data = fertile_pops_all_notNApeds), bins=20)
ggqqplot((fertile_pops_all_notNApeds$Peduncles)^2)
shapiro.test((fertile_pops_all_notNApeds$Peduncles)^2)

## tried squaring, cubing, log transformations. Squaring looks best.


# add sq(pods) col to df
fertile_pops_all_notNApeds$Peduncles_sq <- (fertile_pops_all_notNApeds$Peduncles)^2

```

######### Urb_score: Use Squaring transformation
```{r}

diag_urb_peds_1 <- lm(Peduncles ~ Urb_score * Year, data = urb_scores_peds_all)

par(mfrow=c(2,2))
plot(diag_urb_peds_1)
summary(diag_urb_peds_1)

## Histogram
gg_reshist(diag_urb_peds_1, bins=20)
hist(urb_scores_peds_all$Peduncles)


ggqqplot(urb_scores_peds_all$Peduncles)
## Most data points fall within the envelope but several don't. (towards one end)

bptest(diag_urb_peds_1)
# homoskedastic?

# Shapiro-Wilk normality test
shapiro.test(urb_scores_peds_all$Peduncles)
## From the output, the p-value < 0.05 implying that the distribution of the data are significantly different from normal distribution. We cannot assume the normality. But the biological background for peduncle production backs this up; that distribution would be expected to not be normal anyway.
# looks left-skewed.

hist(urb_scores_peds_all$Peduncles^(1/2), breaks = 12)
hist(log(urb_scores_peds_all$Peduncles + 1), breaks = 12)
hist(urb_scores_peds_all$Peduncles^(2), breaks = 12)

qplot((urb_scores_peds_all$Peduncles)^2, bins = 20)
plot(lm((Peduncles^2) ~ Urb_score * Year, data = urb_scores_peds_all), bins=20)
gg_reshist(lm((Peduncles^2) ~ Urb_score* Year, data = urb_scores_peds_all), bins=20)
ggqqplot((urb_scores_peds_all$Peduncles)^2)

## tried squaring, cubing, log transformations. Squaring looks best.


# add sq(pods) col to df
urb_scores_peds_all$Peduncles_sq <- (urb_scores_peds_all$Peduncles)^2



# ----------------
# try negative binomial

summary(glm.nb(Peduncles ~ Urb_score * Year, data = urb_scores_peds_all))
# AIC is lower than lm



# --------------
# Export residuals, then look at spatial pattern
urb_scores_peds_all$residuals <- residuals(lm((Peduncles ~ Urb_score * Year),data = urb_scores_peds_all))

# new df with site coordinates and residuals
sites1 <- dplyr::rename(sites, Patch_ID = Pop_ID)
urb_scores_peds_all <- as.data.frame(urb_scores_peds_all)
sites_pedresids <- dplyr::full_join(sites1, urb_scores_peds_all, by = 'Patch_ID')


# look at mapped out residuals
 base_map +
   geom_point(data = sites_pedresids, mapping = aes(x = lon, y = lat, shape=Transect.y, color = residuals), size= 2) +
  labs(x = 'Longitude', y = 'Latitude') +
   scale_color_gradient2(low = "blue", 
                         midpoint = 0,
                          mid = "white",
                          high = "red",
                          space="Lab")

```

######## ANOVA
######### City_dist, not urb_score
```{r}
lm.peds.gr.1 <- lm(Peduncles_sq	~ Year * City_dist, data = fertile_pops_all_notNApeds)
lm.peds.gr.1_anova <- car::Anova(lm.peds.gr.1, REML = F)
# Interaction is significant but both main effects aren't.

lm.peds.gr.2 <- lm(Peduncles_sq	~ Year + City_dist, data = fertile_pops_all_notNApeds)
lm.peds.gr.2_anova <- car::Anova(lm.peds.gr.2, REML = F)

AIC(lm.peds.gr.1, lm.peds.gr.2)

```

######### urb_score, not city_dist
```{r}
u_ped_glm_gradient_1 <- lm(Peduncles_sq 	~ Year * Urb_score, data = urb_scores_peds_all)
u_ped_glm_gradient_1_anova <- car::Anova(u_ped_glm_gradient_1, REML = F)
# Nothing significant

u_ped_glm_gradient_2 <- lm(Peduncles_sq 	~ Year + Urb_score, data = urb_scores_peds_all)
u_ped_glm_gradient_2_anova <- car::Anova(u_ped_glm_gradient_2, REML = F)
# Nothing significant

AIC(u_ped_glm_gradient_1, u_ped_glm_gradient_2)

```

####### With transect- USE SQUARING TRANSFORMATION
######## Diagnostics
######### City_dist: USE SQUARING TRANSFORMATION
```{r}
fertile_pops_all_notNApeds_urban <-subset(fertile_pops_all_notNApeds, Transect_ID == "North" | Transect_ID == "South")


urbpeds_lm <- lm(Peduncles ~ City_dist * as.factor(Year) * Transect_ID, data = fertile_pops_all_notNApeds_urban)

par(mfrow=c(2,2))
plot(urbpeds_lm)
summary(urbpeds_lm)

## Histogram
gg_reshist(urbpeds_lm, bins=20)

qplot(fertile_pops_all_notNApeds_urban$Peduncles, bins = 15)

summary(fertile_pops_all_notNApeds_urban$Peduncles)
sd(fertile_pops_all_notNApeds_urban$Peduncles)

ggqqplot(fertile_pops_all_notNApeds_urban$Peduncles)
## Most data points fall within the envelope but several don't. (towards one end)

# Shapiro-Wilk normality test
shapiro.test(fertile_pops_all_notNApeds_urban$Peduncles)
## From the output, the p-value < 0.05 implying that the distribution of the data are significantly different from normal distribution. We cannot assume the normality.

qplot((fertile_pops_all_notNApeds_urban$Peduncles)^2)
plot(lm((Peduncles^2) ~ City_dist * as.factor(Year) * Transect_ID, data = fertile_pops_all_notNApeds_urban), bins=20)
gg_reshist(lm((Peduncles^2) ~ City_dist * as.factor(Year) * Transect_ID, data = fertile_pops_all_notNApeds_urban), bins=20)
ggqqplot((fertile_pops_all_notNApeds_urban$Peduncles)^2)
shapiro.test((fertile_pops_all_notNApeds_urban$Peduncles)^2)
# looks really good!


# add squared peduncles col to df
fertile_pops_all_notNApeds_urban$Peduncles_sq <- (fertile_pops_all_notNApeds_urban$Peduncles)^2

```


######### Urb_score: USE SQUARING TRANSFORMATION
```{r}

diag_urb_peds_2 <- lm(Peduncles ~ Urb_score * as.factor(Year) * Transect_ID, data = urb_scores_peds)

par(mfrow=c(2,2))
plot(diag_urb_peds_2)
summary(diag_urb_peds_2)

## Histogram
gg_reshist(diag_urb_peds_2, bins=20)

ggqqplot(urb_scores_peds$Peduncles)
## Most data points fall within the envelope but several don't. (towards one end)
# Looks left-skewed

# Shapiro-Wilk normality test
shapiro.test(urb_scores_peds$Peduncles)
## From the output, the p-value < 0.05 implying that the distribution of the data are significantly different from normal distribution. We cannot assume the normality.

qplot((urb_scores_peds$Peduncles)^2, bins = 15)
plot(lm((Peduncles^2) ~ Urb_score * as.factor(Year) * Transect_ID, data = urb_scores_peds), bins=20)
gg_reshist(lm((Peduncles^2) ~ Urb_score * as.factor(Year) * Transect_ID, data = urb_scores_peds), bins=20)
ggqqplot((urb_scores_peds$Peduncles)^2)
shapiro.test((urb_scores_peds$Peduncles)^2)
# looks really good!


# add squared peduncles col to df
urb_scores_peds$Peduncles_sq <- (urb_scores_peds$Peduncles)^2

```



######## ANOVA
######### City_dist, not urb_score
```{r}
lm.peds.subt.1 <- lm(Peduncles_sq	~ Year * City_dist * Transect_ID, data = fertile_pops_all_notNApeds_urban)
lm.peds.subt.1_anova <- car::Anova(lm.peds.subt.1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

lm.peds.subt.2 <- lm(Peduncles_sq	~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID, data = fertile_pops_all_notNApeds_urban)
lm.peds.subt.2_anova <- car::Anova(lm.peds.subt.2, REML = F)
# Only city_dist significant. look at main effects and no interactions

lm.peds.subt.3 <- lm(Peduncles_sq	~ Year + City_dist + Transect_ID, data = fertile_pops_all_notNApeds_urban)
lm.peds.subt.3_anova <- car::Anova(lm.peds.subt.3, REML = F)
# City_dist is sig

AIC(lm.peds.subt.1, lm.peds.subt.2, lm.peds.subt.3)

```
######### Urb_score, not city_dist
```{r}
u_ped_glm_subtr_1 <- lm(Peduncles_sq 	~ Year * Urb_score * Transect_ID, data = urb_scores_peds)
u_ped_glm_subtr_1_anova <- car::Anova(u_ped_glm_subtr_1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

u_ped_glm_subtr_2 <- lm(Peduncles_sq 	~ Year + Urb_score + Transect_ID + Year:Urb_score + Year:Transect_ID + Urb_score:Transect_ID, data = urb_scores_peds)
u_ped_glm_subtr_2_anova <- car::Anova(u_ped_glm_subtr_2, REML = F)
# nothing sig

u_ped_glm_subtr_3 <- lm(Peduncles_sq 	~ Year + Urb_score + Transect_ID, data = urb_scores_peds)
u_ped_glm_subtr_3_anova <- car::Anova(u_ped_glm_subtr_3, REML = F)
# nothing sig

AIC(u_ped_glm_subtr_1,u_ped_glm_subtr_2,u_ped_glm_subtr_3)
```

###### GLMER
####### City_dist, not urb_score
```{r}
### No transect yet
# glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist, fertile, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist, fertile, family = "poisson",  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# car::Anova(glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist, fertile, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# # city_dist not significant


# ## add back year
# #### ERROR not converging
# glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist * as.factor(Year), fertile, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))


########### THESE ARE WHAT I'LL USE ###
## do this for only 2018
### no error
peds_glmer_gradient_01 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist, (fertile %>% filter(Year == '2018')), family = "poisson")
peds_glmer_gradient_01_anova <- car::Anova(peds_glmer_gradient_01)
AIC(peds_glmer_gradient_01)
# city_dist not sig

## do this for only 2019
### no error
peds_glmer_gradient_02 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist, (fertile %>% filter(Year == '2019')), family = "poisson")
peds_glmer_gradient_02_anova <- car::Anova(peds_glmer_gradient_02)
AIC(peds_glmer_gradient_02)
# city_dist IS sig




## add transect
# full model
peds_glmer_subtr_1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
car::Anova(peds_glmer_subtr_1)
AIC(peds_glmer_subtr_1)
# only city_dist sig

# full model minus 3-way interaxn
peds_glmer_subtr_1.1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist:as.factor(Year) + as.factor(Year):Transect_ID + City_dist:Transect_ID + City_dist + Transect_ID + as.factor(Year), fertile_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
car::Anova(peds_glmer_subtr_1.1)
AIC(peds_glmer_subtr_1.1)
# AIC <2 from full model

# full model minus 3-way interaxn and urbscore:year
peds_glmer_subtr_1.2 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + as.factor(Year):Transect_ID + Transect_ID:City_dist, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.2_anova <- car::Anova(peds_glmer_subtr_1.2)
AIC(peds_glmer_subtr_1.2)
# lower AIC than full model

# full model minus 3-way interaxn and transect:year
peds_glmer_subtr_1.3 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + as.factor(Year):City_dist + Transect_ID:City_dist, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.3_anova <- car::Anova(peds_glmer_subtr_1.3)
AIC(peds_glmer_subtr_1.3)
# AIC <2 than full model


# full model minus 3-way interaxn and transect:City_dist
peds_glmer_subtr_1.4 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + as.factor(Year):City_dist + Transect_ID:as.factor(Year), fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.4_anova <- car::Anova(peds_glmer_subtr_1.4)
AIC(peds_glmer_subtr_1.4)
# AIC <2 than full model

AIC(peds_glmer_subtr_1,
    peds_glmer_subtr_1.1,
    peds_glmer_subtr_1.2,
    peds_glmer_subtr_1.3,
    peds_glmer_subtr_1.4)
# keep doing backwards selection


# main effects plus year:City_dist
peds_glmer_subtr_1.5 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + as.factor(Year):City_dist, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.5_anova <- car::Anova(peds_glmer_subtr_1.5)
AIC(peds_glmer_subtr_1.5)
# AIC <2 lower than full model

# main effects plus transect:City_dist
peds_glmer_subtr_1.6 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:City_dist, fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.6_anova <- car::Anova(peds_glmer_subtr_1.6)
AIC(peds_glmer_subtr_1.6)
# AIC <2 lower than full model

# main effects plus transect:year
peds_glmer_subtr_1.7 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:as.factor(Year), fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.7_anova <- car::Anova(peds_glmer_subtr_1.7)
AIC(peds_glmer_subtr_1.7)
# AIC <2 lower than full model... continuing backwards selection

# main effects only
peds_glmer_subtr_1.8 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID , fertile_urban, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
peds_glmer_subtr_1.8_anova <- car::Anova(peds_glmer_subtr_1.8)
AIC(peds_glmer_subtr_1.8)
# AIC <<2 from full model


AIC(peds_glmer_subtr_1,
    peds_glmer_subtr_1.1,
    peds_glmer_subtr_1.2,
    peds_glmer_subtr_1.3,
    peds_glmer_subtr_1.4,
    peds_glmer_subtr_1.5,
    peds_glmer_subtr_1.6,
    peds_glmer_subtr_1.7,
    peds_glmer_subtr_1.8)
# best models 1.2, 1.5, 1.6, 1.7, 1.8

peds_glmer_gradient_list <- list(peds_glmer_gradient_01,
                                 peds_glmer_gradient_02)

peds_glmer_subtr_list <- list(peds_glmer_subtr_1,
                              peds_glmer_subtr_1.1,
                              peds_glmer_subtr_1.2,
                              peds_glmer_subtr_1.3,
                              peds_glmer_subtr_1.4,
                              peds_glmer_subtr_1.5,
                              peds_glmer_subtr_1.6,
                              peds_glmer_subtr_1.7,
                              peds_glmer_subtr_1.8)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_peds_citydist.csv')
i<-0
for (x in peds_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in peds_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()

```


####### urb_score, not City_dist
```{r}
### No transect yet
u_peds_glmer_gradient_1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score * as.factor(Year), urb_scores_peds_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_peds_glmer_gradient_1_anova <- car::Anova(u_peds_glmer_gradient_1)
# nothing sig

u_peds_glmer_gradient_1.1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score + as.factor(Year), urb_scores_peds_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_peds_glmer_gradient_1.1_anova <- car::Anova(u_peds_glmer_gradient_1.1)
# nothing sig

AIC(u_peds_glmer_gradient_1, u_peds_glmer_gradient_1.1)




## add transect
# full model
u_peds_glmer_subtr_1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score * as.factor(Year) * Transect_ID, urb_scores_peds_all_long, family = "poisson",
            glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_peds_glmer_subtr_1_anova <- car::Anova(u_peds_glmer_subtr_1)
AIC(u_peds_glmer_subtr_1)
# 3-way interaxn marg sig plus one 2-way interaxn

# full model minus 3-way interaxn
u_peds_glmer_subtr_1.1 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score:Transect_ID + as.factor(Year):Transect_ID + Urb_score:as.factor(Year) + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.1)
u_peds_glmer_subtr_1.1_anova <- car::Anova(u_peds_glmer_subtr_1.1)
# AIC <2 from full model

# full model minus 3-way interaxn and urbscore:year
u_peds_glmer_subtr_1.2 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score:Transect_ID + as.factor(Year):Transect_ID + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.2)
u_peds_glmer_subtr_1.2_anova <- car::Anova(u_peds_glmer_subtr_1.2)
# AIC >2 from full model

# full model minus 3-way interaxn and urbscore:transect
u_peds_glmer_subtr_1.3 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + as.factor(Year):Transect_ID + Urb_score:as.factor(Year) + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.3)
u_peds_glmer_subtr_1.3_anova <- car::Anova(u_peds_glmer_subtr_1.3)
# AIC <2 from full model

# full model minus 3-way interaxn and transect:year
u_peds_glmer_subtr_1.4 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score:Transect_ID + Urb_score:as.factor(Year) + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.4)
u_peds_glmer_subtr_1.4_anova <- car::Anova(u_peds_glmer_subtr_1.4)
# AIC <2 from full model

# main effects + urbscore:transect
u_peds_glmer_subtr_1.5 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score:Transect_ID + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.5)
u_peds_glmer_subtr_1.5_anova <- car::Anova(u_peds_glmer_subtr_1.5)
# AIC >2 from full model

# main effects + urbscore:year
u_peds_glmer_subtr_1.6 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score:as.factor(Year) +  Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.6)
u_peds_glmer_subtr_1.6_anova <- car::Anova(u_peds_glmer_subtr_1.6)
# AIC <2 from full model

# main effects + transect:year
u_peds_glmer_subtr_1.7 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Transect_ID:as.factor(Year) +  Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.7)
u_peds_glmer_subtr_1.7_anova <- car::Anova(u_peds_glmer_subtr_1.7)
# AIC >2 from full model

# main effects
u_peds_glmer_subtr_1.8 <- glmer(as.numeric(Peduncles) ~ (1|Patch_ID) + Urb_score + Transect_ID + as.factor(Year), urb_scores_peds_all_long, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_peds_glmer_subtr_1.8)
u_peds_glmer_subtr_1.8_anova <- car::Anova(u_peds_glmer_subtr_1.8)
# AIC >2 from full model


u_peds_glmer_gradient_list <- list(u_peds_glmer_gradient_1,
                                   u_peds_glmer_gradient_1.1)

u_peds_glmer_subtr_list <- list(u_peds_glmer_subtr_1,
                                u_peds_glmer_subtr_1.1,
                                u_peds_glmer_subtr_1.2,
                                u_peds_glmer_subtr_1.3,
                                u_peds_glmer_subtr_1.4,
                                u_peds_glmer_subtr_1.5,
                                u_peds_glmer_subtr_1.6,
                                u_peds_glmer_subtr_1.7,
                                u_peds_glmer_subtr_1.8)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/glmer_peds_urbscore.csv')
i<-0
for (x in u_peds_glmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in u_peds_glmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```

##### Height (Sept)
###### LM
####### Without transect
######## Diagnostics
######### City_dist- NO TRANSFORMATION NEEDED
```{r}

fertile_pops_all_height_18_19_sept <- fertile_pops_all[!is.na(fertile_pops_all$Height_Sept),]

allheight_lm_sept <- lm(Height_Sept ~ City_dist * Year, data = fertile_pops_all_height_18_19_sept)

par(mfrow=c(2,2))
plot(allheight_lm_sept)
summary(allheight_lm_sept)

ggqqplot(fertile_pops_all_height_18_19_sept$Height_Sept)
# all data points within envelope

# Histogram
gg_reshist(allheight_lm_sept, bins=20)
# looks normal!

# Shapiro-Wilk normality test
shapiro.test(fertile_pops_all_height_18_19_sept$Height_Sept)
## From the output, the p-value > 0.05 implying that the distribution of the data are NOT significantly different from normal distribution. We can assume normality!
```


######### Urb_score- NO TRANSFORMATION NEEDED
```{r}
diag_urb_height_1 <- lm(Height_Sept ~ Urb_score * Year, data = urb_scores_height_all)

par(mfrow=c(2,2))
plot(diag_urb_height_1)
summary(diag_urb_height_1)

ggqqplot(urb_scores_height_all$Height_Sept)
# all data points within envelope

# Histogram
gg_reshist(diag_urb_height_1, bins=20)
# looks normal!

# Shapiro-Wilk normality test
shapiro.test(urb_scores_height_all$Height_Sept)
## From the output, the p-value > 0.05 implying that the distribution of the data are NOT significantly different from normal distribution. We can assume normality!
```



######## ANOVA
######### City_dist, not urb_score
```{r}
lm.height.gr.1 <- lm(Height_Sept	~ Year * City_dist, data = fertile_pops_all_height_18_19_sept)
lm.height.gr.1_anova <- car::Anova(lm.height.gr.1, REML = F)
# No effects or interactions significant,

lm.height.gr.2 <- lm(Height_Sept ~ Year + City_dist, data = fertile_pops_all_height_18_19_sept)
lm.height.gr.2_anova <- car::Anova(lm.height.gr.2, REML = F)
# No effects or interactions significant,

AIC(lm.height.gr.1, lm.height.gr.2)

```

######### urb_score
```{r}
u_height_glm_gradient_1 <- lm(Height_Sept 	~ Year * Urb_score, data = urb_scores_height_all)
u_height_glm_gradient_1_anova <- car::Anova(u_height_glm_gradient_1, REML = F)
# No interactions significant,

u_height_glm_gradient_2 <- lm(Height_Sept 	~ Year + Urb_score, data = urb_scores_height_all)
u_height_glm_gradient_2_anova <- car::Anova(u_height_glm_gradient_2, REML = F)
# No main effects significant,

AIC(u_height_glm_gradient_1, u_height_glm_gradient_2)

```


####### With transect
######## Diagnostics
######### City_dist: NO TRANSFORMATION NEEDED
```{r}

# First, remove rural points to avoid collinearity.

fertile_pops_all_height_18_19_urban_sept <-subset(fertile_pops_all, Transect_ID == "North" | Transect_ID == "South")

urbheight_lm_sept <- lm(Height_Sept ~ City_dist * Year * Transect_ID, data = fertile_pops_all_height_18_19_urban_sept)

par(mfrow=c(2,2))
plot(urbheight_lm_sept)
# looks like fanning (heteroskedasticity) 
## Felipe says it's not a big deal, esp. since dist_city is not normally distributed (b/c of my study design)
bptest(urbheight_lm_sept) # p = 0.153... not significant = there'sNO heteroskedasticity here

summary(urbheight_lm_sept)
hist(fertile_pops_all_height_18_19_urban_sept$City_dist)

ggqqplot(fertile_pops_all_height_18_19_urban_sept$Height_Sept)
## Data points don't fit in envelope towards right margin.

# Histogram
gg_reshist(urbheight_lm, bins=20)
# slightly right-skewed

# Shapiro-Wilk normality test
shapiro.test(fertile_pops_all_height_18_19_urban_sept$Height_Sept)
## From the output, the p-value > 0.05 implying that the distribution of the data are NOT significantly different from normal distribution. We can assume normality.
```


######### Urb_score: NO TRANSFORMATION NEEDED
```{r}
diag_urb_height_2 <- lm(Height_Sept ~ Urb_score * Year * Transect_ID, data = urb_scores_height)

par(mfrow=c(2,2))
plot(diag_urb_height_2)
# looks like fanning (heteroskedasticity) 
## Felipe says it's not a big deal, esp. since dist_city is not normally distributed (b/c of my study design)
bptest(diag_urb_height_2) # there'sNO heteroskedasticity here

summary(diag_urb_height_2)
hist(urb_scores_height$Urb_score)

ggqqplot(urb_scores_height$Height_Sept)
## Data points don't fit in envelope towards right margin.

# Histogram
gg_reshist(diag_urb_height_2, bins=20)
# slightly right-skewed

# Shapiro-Wilk normality test
shapiro.test(urb_scores_height$Height_Sept)
## From the output, the p-value > 0.05 implying that the distribution of the data are NOT significantly different from normal distribution. We can assume normality.
```



######## ANOVA
######### City_dist, not urb_score
```{r}
lm.height.subt.1 <- lm(Height_Sept 	~ Year * City_dist * Transect_ID, data = fertile_pops_all_height_18_19_urban_sept)
lm.height.subt.1_anova <- car::Anova(lm.height.subt.1, REML = F)
# nothing sig

lm.height.subt.2 <- lm(Height_Sept ~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID, data = fertile_pops_all_height_18_19_urban_sept)
lm.height.subt.2_anova <- car::Anova(lm.height.subt.2, REML = F)
# Nothing significant, so removing interactions

lm.height.subt.3 <- lm(Height_Sept 	~ Year + City_dist + Transect_ID, data = fertile_pops_all_height_18_19_urban_sept)
lm.height.subt.3_anova <- car::Anova(lm.height.subt.3, REML = F)
# nothing significant

AIC(lm.height.subt.1, lm.height.subt.2, lm.height.subt.3)
```


######### urb_score, not city_dist
```{r}
u_height_glm_subtr_1 <- lm(Height_Sept 	~ Year * Urb_score * Transect_ID, data = urb_scores_height)
u_height_glm_subtr_1_anova <- car::Anova(u_height_glm_subtr_1, REML = F)
# 3-way interaction not significant, so let's look at lower-level interactions and main effects.

u_height_glm_subtr_2 <-lm(Height_Sept 	~ Year + Urb_score + Transect_ID + Year:Urb_score + Year:Transect_ID + Urb_score:Transect_ID, data = urb_scores_height) 
u_height_glm_subtr_2_anova <- car::Anova(u_height_glm_subtr_2, REML = F)
# Nothing significant, so removing interactions

u_height_glm_subtr_3 <- lm(Height_Sept 	~ Year + Urb_score + Transect_ID, data = urb_scores_height)
u_height_glm_subtr_3_anova <- car::Anova(u_height_glm_subtr_3, REML = F)
# nothing sig

AIC(u_height_glm_subtr_1, u_height_glm_subtr_2, u_height_glm_subtr_3)
```



###### LMER
####### City_dist, not urb-score
```{r}
height_lmer_gradient_1 <- lmer(Height_Sept ~ (1|Patch_ID) + City_dist * as.factor(Year), fertile, REML = F)
height_lmer_gradient_1_anova <- car::Anova(height_lmer_gradient_1)
AIC(height_lmer_gradient_1)
# year is significant but not interaxn

height_lmer_gradient_1.1 <- lmer(Height_Sept ~ (1|Patch_ID) + City_dist + as.factor(Year), fertile, REML = F)
height_lmer_gradient_1.1_anova <- car::Anova(height_lmer_gradient_1.1)
AIC(height_lmer_gradient_1.1)
# year is significant

AIC(height_lmer_gradient_1, height_lmer_gradient_1.1)



# ADD SUBTRANSECTS
# full model
height_lmer_subtr_01 <- lmer(Height_Sept ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, fertile_urban, REML = F)
height_lmer_subtr_01_anova <- car::Anova(height_lmer_subtr_01)
AIC(height_lmer_subtr_01)
# 3-way interaction significant, as well as Year:City_dist: and Year

# full model minus 3-way interaxn
height_lmer_subtr_02 <- lmer(Height_Sept ~ (1|Patch_ID) + City_dist:Transect_ID + Transect_ID:as.factor(Year) + City_dist:as.factor(Year) + City_dist + as.factor(Year) + Transect_ID, fertile_urban, REML = F)
height_lmer_subtr_02_anova <- car::Anova(height_lmer_subtr_02)
AIC(height_lmer_subtr_02)
# AIC >2 from full model; stopping here



height_lmer_gradient_list <- list(height_lmer_gradient_1,
                                  height_lmer_gradient_1.1)

height_lmer_subtr_list <- list(height_lmer_subtr_01,
                               height_lmer_subtr_02)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/lmer_height_citydist.csv')
i<-0
for (x in height_lmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in height_lmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```

####### urb-score, not City_dist
```{r}
u_height_lmer_gradient_1 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score * as.factor(Year), urb_scores_height_long, REML = F)
AIC(u_height_lmer_gradient_1)
u_height_lmer_gradient_1_anova <- car::Anova(u_height_lmer_gradient_1)
# year and interaxn significant

u_height_lmer_gradient_2 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year), urb_scores_height_long, REML = F)
AIC(u_height_lmer_gradient_2)
u_height_lmer_gradient_1_anova <- car::Anova(u_height_lmer_gradient_2)




# ADD SUBTRANSECTS
# full model
u_height_lmer_subtr_1 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score * as.factor(Year) * Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1_anova <- car::Anova(u_height_lmer_subtr_1)
AIC(u_height_lmer_subtr_1)
# only year significant

# full model minus 3-way interaxn
u_height_lmer_subtr_1.1 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:as.factor(Year) + Urb_score:Transect_ID + as.factor(Year):Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.1_anova <- car::Anova(u_height_lmer_subtr_1.1)
AIC(u_height_lmer_subtr_1.1)
# AIC less than full model

# full model minus 3-way interaxn and urbscore:year
u_height_lmer_subtr_1.2 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:Transect_ID + as.factor(Year):Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.2_anova <- car::Anova(u_height_lmer_subtr_1.2)
AIC(u_height_lmer_subtr_1.2)
# AIC less than full model

# full model minus 3-way interaxn and urbscore:transect
u_height_lmer_subtr_1.3 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:as.factor(Year) + as.factor(Year):Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.3_anova <- car::Anova(u_height_lmer_subtr_1.3)
AIC(u_height_lmer_subtr_1.3)
# AIC less than full model

# full model minus 3-way interaxn and year:transect
u_height_lmer_subtr_1.4 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:as.factor(Year) + Urb_score:Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.4_anova <- car::Anova(u_height_lmer_subtr_1.4)
AIC(u_height_lmer_subtr_1.4)
# AIC less than full model

# main effects + urbscore:transect
u_height_lmer_subtr_1.5 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + Urb_score:Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.5_anova <- car::Anova(u_height_lmer_subtr_1.5)
AIC(u_height_lmer_subtr_1.5)
# AIC less than full model

# main effects + year:transect
u_height_lmer_subtr_1.6 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.6_anova <- car::Anova(u_height_lmer_subtr_1.6)
AIC(u_height_lmer_subtr_1.6)
# AIC less than full model

# main effects + year:urbscore
u_height_lmer_subtr_1.7 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID + as.factor(Year):Urb_score, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.7_anova <- car::Anova(u_height_lmer_subtr_1.7)
AIC(u_height_lmer_subtr_1.7)
# AIC less than full model

# main effects
u_height_lmer_subtr_1.8 <- lmer(Height_Sept ~ (1|Patch_ID) + Urb_score + as.factor(Year) + Transect_ID, urb_scores_height_all_long, REML = F)
u_height_lmer_subtr_1.8_anova <- car::Anova(u_height_lmer_subtr_1.8)
AIC(u_height_lmer_subtr_1.8)
# AIC less than full model


u_height_lmer_gradient_list <- list(u_height_lmer_gradient_1,
                                    u_height_lmer_gradient_2)

u_height_lmer_subtr_list <- list(u_height_lmer_subtr_1,
                                 u_height_lmer_subtr_1.1,
                                 u_height_lmer_subtr_1.2,
                                 u_height_lmer_subtr_1.3,
                                 u_height_lmer_subtr_1.4,
                                 u_height_lmer_subtr_1.5,
                                 u_height_lmer_subtr_1.6,
                                 u_height_lmer_subtr_1.7,
                                 u_height_lmer_subtr_1.8)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/lmer_height_urbscore.csv')
i<-0
for (x in u_height_lmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in u_height_lmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```


##### Pods per peduncle (i.e. follicles per inflorescence)
###### Make new df
```{r}
# pop-level datasets
fertile_pops_all$pods_per_ped <- fertile_pops_all$Total_Pods / fertile_pops_all$Peduncles
fertile_pops_all_podsperped <- fertile_pops_all[complete.cases(fertile_pops_all$pods_per_ped), ]

## urban subset
fertile_pops_all_podsperped_urban <- fertile_pops_all_podsperped %>% filter(Transect_ID != 'Rural')

# plant-level datasets
fertile$pods_per_ped <- fertile$Total_Pods / fertile$Peduncles
fertile_urban <- fertile %>% filter(Transect_ID != 'Rural')
```

###### LM
####### Without transect
######## Diagnostics
######### City_dist: USE SQRT TRANSFORMATION
```{r}
lm(pods_per_ped ~ City_dist * Year , data = fertile_pops_all_podsperped)

par(mfrow=c(2,2))
plot(lm(pods_per_ped ~ City_dist * Year , data = fertile_pops_all_podsperped))
summary(lm(pods_per_ped ~ City_dist * Year , data = fertile_pops_all_podsperped))

qplot(fertile_pops_all_podsperped$pods_per_ped)

lmtest::bptest(lm(pods_per_ped ~ City_dist * Year , data = fertile_pops_all_podsperped)) 
# plot is heteroskedastic
## Felipe says it's not a big deal, esp. since dist_city is not normally distributed (b/c of my study design)

gg_reshist(lm((pods_per_ped) ~ City_dist * Year, data = fertile_pops_all_podsperped), bins=20)
ggqqplot(fertile_pops_all_podsperped$pods_per_ped)
## Most data points fall within the envelope but some don't. (towards one end)



# try  transformations
gg_reshist(lm((pods_per_ped)^(1/2) ~ City_dist * Year, data = fertile_pops_all_podsperped), bins=20)
plot(lm((pods_per_ped)^(1/2) ~ City_dist * Year , data = fertile_pops_all_podsperped))
ggqqplot((fertile_pops_all_podsperped$pods_per_ped)^(1/2))
shapiro.test((fertile_pops_all_podsperped$pods_per_ped)^(1/2))
##### GOING WITH THIS ONE. LOOKS GOOD.



# add sqrt(pods) col to df
fertile_pops_all_podsperped$pods_per_ped_sqrt <- sqrt(fertile_pops_all_podsperped$pods_per_ped)
```

######### Urb_score: No transformation necessary
```{r}
diag_urb_podperped_1 <- lm(pods_per_ped ~ Urb_score * Year , data = urb_scores_podperped_all)

par(mfrow=c(2,2))
plot(diag_urb_podperped_1)
summary(diag_urb_podperped_1)

qplot(urb_scores_podperped_all$pods_per_ped, bins = 20)

lmtest::bptest(diag_urb_podperped_1)
# Marginally homoskedastic

gg_reshist(diag_urb_podperped_1, bins=20)
ggqqplot(urb_scores_podperped_all$pods_per_ped)
## Most data points fall within the envelope but some don't. (towards one end). Looks very normal except for those 3 potential outliers
# Good enough.


# try squaring trnasformation
gg_reshist(lm(pods_per_ped^(1/2) ~ Urb_score * Year , data = urb_scores_podperped_all), bins=20)
plot(lm(pods_per_ped^(1/2) ~ Urb_score * Year , data = urb_scores_podperped_all))
lmtest::bptest(lm(pods_per_ped^(1/2) ~ Urb_score * Year , data = urb_scores_podperped_all))
# now it's heteroskedastic? doesn't look like it

```


######## ANOVA
######### City_dist, not urb_score
```{r}
lm.podperped.gr.1 <- lm(pods_per_ped_sqrt	~ Year * City_dist, data = fertile_pops_all_podsperped)
lm.podperped.gr.1_anova <- car::Anova(lm.podperped.gr.1, REML = F)
# Interaction  not significant but city_dist is

lm.podperped.gr.2 <- lm(pods_per_ped_sqrt	~ Year + City_dist, data = fertile_pops_all_podsperped)
lm.podperped.gr.2_anova <- car::Anova(lm.podperped.gr.2, REML = F)
# city_dist sig

AIC(lm.podperped.gr.1, lm.podperped.gr.2)
```

######### Urb_score
```{r}
u_podperped_glm_gradient_1 <- lm(pods_per_ped 	~ Year * Urb_score, data = urb_scores_podperped_all)
u_podperped_glm_gradient_1_anova <- car::Anova(u_podperped_glm_gradient_1, REML = F)
# Interaction  not significant.

u_podperped_glm_gradient_2 <- lm(pods_per_ped 	~ Year + Urb_score, data = urb_scores_podperped_all)
u_podperped_glm_gradient_2_anova <- car::Anova(u_podperped_glm_gradient_2, REML = F)# Urb_score sig
# urb_score sig

AIC(u_podperped_glm_gradient_1, u_podperped_glm_gradient_2)
```


####### With transect
######## Diagnostics
######### City_dist- USE SQRT TRANSFORMATION
```{r}
fertile_pops_all_podsperped_urban <- fertile_pops_all_podsperped %>% filter(Transect_ID != 'Rural')

lm(pods_per_ped_sqrt ~ City_dist * Year * Transect_ID, data = fertile_pops_all_podsperped_urban)

par(mfrow=c(2,2))
plot(lm(pods_per_ped_sqrt ~ City_dist * Year * Transect_ID, data = fertile_pops_all_podsperped_urban))

summary(lm(pods_per_ped_sqrt ~ City_dist * Year * Transect_ID, data = fertile_pops_all_podsperped_urban))

ggqqplot(fertile_pops_all_podsperped_urban$pods_per_ped_sqrt)

# Histogram
gg_reshist(lm(pods_per_ped_sqrt ~ City_dist * Year * Transect_ID, data = fertile_pops_all_podsperped_urban) , bins=20)

# I think it looks normal enough.
```


######### Urb_score- No transformation necessary
```{r}

diag_urb_podperped_2 <- lm(pods_per_ped ~ Urb_score * Year * Transect_ID, data = urb_scores_podperped)

par(mfrow=c(2,2))
plot(diag_urb_podperped_2)

ggqqplot(urb_scores_podperped$pods_per_ped)
bptest(diag_urb_podperped_2)
# homoskedastic ?

# Histogram
gg_reshist(diag_urb_podperped_2, bins=20)
shapiro.test((urb_scores_podperped$pods_per_ped))

# Slight right skew but overall looks close to normal

```

######## ANOVA
######### City_dist, not urb_score
```{r}
lm.podperped.subt.1 <- lm(pods_per_ped 	~ Year * City_dist * Transect_ID, data = fertile_pops_all_podsperped_urban)
lm.podperped.subt.1_anova <- car::Anova(lm.podperped.subt.1, REML = F)
# nothing sig

lm.podperped.subt.2 <- lm(pods_per_ped 	~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID, data = fertile_pops_all_podsperped_urban)
lm.podperped.subt.2_anova <- car::Anova(lm.podperped.subt.2, REML = F)
# Nothing significant

lm.podperped.subt.3 <- lm(pods_per_ped 	~ Year + City_dist + Transect_ID, data = fertile_pops_all_podsperped_urban)
lm.podperped.subt.3_anova <- car::Anova(lm.podperped.subt.3, REML = F)
# Nothing significant

AIC(lm.podperped.subt.1, lm.podperped.subt.2, lm.podperped.subt.3)
```

######### urb_score, not City_dist
```{r}
u_podperped_glm_subtr_1 <- lm(pods_per_ped 	~ Year * Urb_score * Transect_ID, data = urb_scores_podperped)
u_podperped_glm_subtr_1_anova <- car::Anova(u_podperped_glm_subtr_1, REML = F)
# 3-way interaction IS significant but no 2-way interaxns are, or main effects

u_podperped_glm_subtr_2 <- lm(pods_per_ped 	~ Year:Urb_score:Transect_ID + Year + Urb_score + Transect_ID, data = urb_scores_podperped)
u_podperped_glm_subtr_2_anova <- car::Anova(u_podperped_glm_subtr_2, REML = F)
# nothing sig now

AIC(u_podperped_glm_subtr_1, u_podperped_glm_subtr_2)

```


###### LMER
####### ANOVA
######## City_dist, not urb-score
```{r}
### No transect yet
# full model
podperped_lmer_gradient_01 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + City_dist * as.factor(Year), fertile, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
podperped_lmer_gradient_01_anova <- car::Anova(podperped_lmer_gradient_01)
# only city_dist marginally sig


podperped_lmer_gradient_02 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + City_dist + as.factor(Year), fertile, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
podperped_lmer_gradient_02_anova <- car::Anova(podperped_lmer_gradient_02)
# only city_dist marginally sig

AIC(podperped_lmer_gradient_01, podperped_lmer_gradient_02)




## add transect
# full model
podperped_lmer_subtr_01 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + City_dist * as.factor(Year) * Transect_ID, fertile_urban, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
car::Anova(podperped_lmer_subtr_01)
AIC(podperped_lmer_subtr_01)
# nothing sig

# full model minus 3-way interaxn
podperped_lmer_subtr_02 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + City_dist + as.factor(Year) + Transect_ID + Transect_ID:as.factor(Year) + Transect_ID:City_dist + City_dist:as.factor(Year), fertile_urban, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_02)
# AIC < full model

# full model minus 3-way interaxn and Transect_ID:as.factor(Year) 
podperped_lmer_subtr_03 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  # Transect_ID:as.factor(Year) +
                                  Transect_ID:City_dist +
                                  City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_03)
# AIC < full model


# full model minus 3-way interaxn and Transect_ID:citydist 
podperped_lmer_subtr_04 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  Transect_ID:as.factor(Year) +
                                  # Transect_ID:City_dist +
                                  City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_04)
# AIC < full model

# full model minus 3-way interaxn and City_dist:as.factor(Year)
podperped_lmer_subtr_05 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  Transect_ID:as.factor(Year) +
                                  Transect_ID:City_dist,
                                  # City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_05)
# AIC < full model


# main effects + Transect_ID:as.factor(Year)
podperped_lmer_subtr_06 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  Transect_ID:as.factor(Year),
                                  # Transect_ID:City_dist +
                                  # City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_06)
# AIC < full model


# main effects + Transect_ID:citydist
podperped_lmer_subtr_07 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  # Transect_ID:as.factor(Year),
                                  Transect_ID:City_dist,
                                  # City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_07)
# AIC < full model


# main effects + City_dist:as.factor(Year)
podperped_lmer_subtr_08 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID +
                                  # Transect_ID:as.factor(Year),
                                  # Transect_ID:City_dist,
                                  City_dist:as.factor(Year),
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_08)
# AIC < full model

# main effects 
podperped_lmer_subtr_09 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                  City_dist +
                                  as.factor(Year) +
                                  Transect_ID,
                                fertile_urban, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(podperped_lmer_subtr_09)
# AIC < full model





podperped_lmer_gradient_list <- list(podperped_lmer_gradient_01,
                                     podperped_lmer_gradient_02)

podperped_lmer_subtr_list <- list(podperped_lmer_subtr_01,
                                  podperped_lmer_subtr_02,
                                  podperped_lmer_subtr_03,
                                  podperped_lmer_subtr_04,
                                  podperped_lmer_subtr_05,
                                  podperped_lmer_subtr_06,
                                  podperped_lmer_subtr_07,
                                  podperped_lmer_subtr_08,
                                  podperped_lmer_subtr_09)


sink('Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/lmer_podperped_citydist.csv')
i<-0
for (x in podperped_lmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in podperped_lmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```


######## urb-score, not City_dist
```{r}
### No transect yet
u_podsperped_lmer_gradient_1 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + Urb_score * as.factor(Year), urb_scores_podsperped_long, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_podsperped_lmer_gradient_1_anova <- car::Anova(u_podsperped_lmer_gradient_1)
# only urb_score marginally sig


u_podsperped_lmer_gradient_1.1 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + Urb_score + as.factor(Year), urb_scores_podsperped_long, REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
u_podsperped_lmer_gradient_1.1_anova <- car::Anova(u_podsperped_lmer_gradient_1.1)
# only urb_score sig

AIC(u_podsperped_lmer_gradient_1, u_podsperped_lmer_gradient_1.1)



## add transect
#full model
u_podsperped_lmer_subtr_01 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) + Urb_score * as.factor(Year) * Transect_ID, urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
car::Anova(u_podsperped_lmer_subtr_01)
AIC(u_podsperped_lmer_subtr_01)
# 3-way interaxn marg sig & AIC is ~397

# full model minus 3-way interaxn
u_podsperped_lmer_subtr_02 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     Urb_score:as.factor(Year) +
                                     Urb_score:Transect_ID +
                                     as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
car::Anova(u_podsperped_lmer_subtr_02)
AIC(u_podsperped_lmer_subtr_02)
# AIC <2 above full model... continuing


# full model minus 3-way interaxn and urbscore:year
u_podsperped_lmer_subtr_03 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     # Urb_score:as.factor(Year) +
                                     Urb_score:Transect_ID +
                                     as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_03)
# AIC lower than full model


# full model minus 3-way interaxn and Urb_score:Transect_ID
u_podsperped_lmer_subtr_04 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     Urb_score:as.factor(Year) +
                                     # Urb_score:Transect_ID +
                                     as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_04)
# AIC lower than full model

# full model minus 3-way interaxn and year:Transect_ID
u_podsperped_lmer_subtr_05 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     Urb_score:as.factor(Year) +
                                     Urb_score:Transect_ID +
                                     # as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_05)
# AIC close to full model


# main effects + urbscore:year
u_podsperped_lmer_subtr_06 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     Urb_score:as.factor(Year) +
                                     # Urb_score:Transect_ID +
                                     # as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_06)
# AIC lower than full model


# main effects + urbscore:transect
u_podsperped_lmer_subtr_07 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     # Urb_score:as.factor(Year) +
                                     Urb_score:Transect_ID +
                                     # as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_07)
# AIC lower than full model

# main effects + year:transect
u_podsperped_lmer_subtr_08 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     # Urb_score:as.factor(Year) +
                                     # Urb_score:Transect_ID +
                                     as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_08)
# AIC lower than full model

# main effects only
u_podsperped_lmer_subtr_09 <- lmer(as.numeric(pods_per_ped) ~ (1|Patch_ID) +
                                     # Urb_score:as.factor(Year) +
                                     # Urb_score:Transect_ID +
                                     # as.factor(Year):Transect_ID +
                                     Urb_score +
                                     as.factor(Year) + 
                                     Transect_ID,
                                   urb_scores_podsperped_all_long, REML = F,
            lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
AIC(u_podsperped_lmer_subtr_09)
# AIC lower than full model


u_podperped_lmer_gradient_list <- list(u_podsperped_lmer_gradient_1,
                                     u_podsperped_lmer_gradient_1.1)

u_podperped_lmer_subtr_list <- list(u_podsperped_lmer_subtr_01,
                                   u_podsperped_lmer_subtr_02,
                                   u_podsperped_lmer_subtr_03,
                                   u_podsperped_lmer_subtr_04,
                                   u_podsperped_lmer_subtr_05,
                                   u_podsperped_lmer_subtr_06,
                                   u_podsperped_lmer_subtr_07,
                                   u_podsperped_lmer_subtr_08,
                                   u_podsperped_lmer_subtr_09)


sink('~/R_Projects/Chapter1/Figures_Tables/Q1_Q2_ANOVA/model_selection_confirmation/lmer_podperped_urbscore.csv')
i<-0
for (x in u_podperped_lmer_gradient_list) {
    i<-i+1
    cat('Q1 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}

i<-0

for (x in u_podperped_lmer_subtr_list) {
    i<-i+1
    cat('Q2 Model ', i)
    cat('\n')
    write.csv(car::Anova(x))
    write.csv(r.squaredGLMM(x)[1,])
    cat('AIC: ', AIC(x)[1])
    cat('\n')
    cat('\n')
}
i<-0
sink()
```



###### plant-level means
The point of this is to test whether the complicated glmer model is better than the simple lmer. Additionally, is the lm better than lmer? The simpler model will make the regression results easier to interpret if, in fact, the simplest model provides the same conclusions/results as the most complicated.
The lm uses population-level means while lmer and glmer use plant-level data.
```{r}
# Make new dfs with hierarchical means
## make new df w/plant-level means
# long_plant_means_pods <- fertile_long %>% group_by(Patch_ID, Year, Pop_ID, Plant_Num) %>%
#     dplyr::summarise(
#       Pods_per_plant=mean(Viable_Pods,na.rm = TRUE),
#       City_dist=mean(City_dist),
#       Transect_ID=first(Transect_ID),
#       Plants_present_2018=mean(Plants_present_2018,na.rm=TRUE),
#       nPlants=n()
#       )

# try out new glmer
v1 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year), long_plant_means_pods, family = "poisson")
summary(v1)
car::Anova(v1)
# Year marginally sig. Removing interaxn

v1.1 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist + as.factor(Year), long_plant_means_pods, family = "poisson")
summary(v1.1)
car::Anova(v1.1)
# Year marginally sig. Removing city_dist

v1.2 <- glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + as.factor(Year), long_plant_means_pods, family = "poisson")
summary(v1.2)
v1.21 <- car::Anova(v1.2)
# Year marginally sig




# try out new glmer- URBAN SUBTRANSECTS
glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * Transect_ID * as.factor(Year), (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# Won't converge... removing year

### TRYING ALL SECONDARY INTERAXNS SEPARATELY
car::Anova(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * Transect_ID, (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Nothing sig

car::Anova(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + City_dist * as.factor(Year), (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# city x year interaxn is highly sig

car::Anova(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + Transect_ID * as.factor(Year), (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Transect x year interaxn is sig

## ALL SECONDARY INTERAXNS... NO TERTIARY
car::Anova(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + Transect_ID:City_dist + Transect_ID:as.factor(Year) + City_dist:as.factor(Year) + as.factor(Year) + Transect_ID + City_dist, (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# both interaxns with year are sig, but not city x transect, so removing that


summary(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + Transect_ID:as.factor(Year) + City_dist:as.factor(Year) + as.factor(Year) + Transect_ID + City_dist, (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))

v2 <- car::Anova(glmer(as.numeric(Pods_per_plant) ~ (1|Patch_ID) + Transect_ID:as.factor(Year) + City_dist:as.factor(Year) + as.factor(Year) + Transect_ID + City_dist, (long_plant_means_pods %>% filter(Transect_ID != 'Rural')), family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# two interaxns still sig. Best model


```


##### Plant density (plants per sq m of patch, as observed in 2018)
###### LM
####### Without transect
######## Diagnostics- can't transform data and assume normality. Go with non-parametric tests?
```{r}
# Removing rows with NA and only keeping data from 2018, since I only quantified patch size and plant density in that year.
density_18 <- AvgVars_byPatch[!is.na(AvgVars_byPatch$density_sqm_18),] %>% filter(Year == '2018')

density_lm <- lm(density_sqm_18 ~ City_dist * Year, data = density_18)

par(mfrow=c(2,2))
plot(density_lm)
summary(density_lm)

ggqqplot(density_18$density_sqm_18)
gg_reshist(density_lm, bins=20)
# major right skew

## try transformation.
##################################

## tried square, cube + roots: not strong enough
par(mfrow=c(2,2))
plot(lm(log(density_sqm_18^(1/10) ~ City_dist , data = density_18 )))
ggqqplot(density_18$density_sqm_18^(1/10))
gg_reshist(lm(density_sqm_18^(1/10) ~ City_dist , data = density_18 ), bins=20)

## tried log(x): makes it into a bimodal distribution... looks much better but not enough, I don't think
par(mfrow=c(2,2))
plot(lm(log(density_sqm_18) ~ City_dist , data = density_18 ))
ggqqplot(log(density_18$density_sqm_18))
gg_reshist(lm(log(density_sqm_18) ~ City_dist , data = density_18 ), bins=20)

# tried reciprocal transformation (1/x): still have ~20 data points not fitting
par(mfrow=c(2,2))
plot(lm((1/(density_sqm_18)) ~ City_dist , data = density_18 ))
ggqqplot((1/(density_18$density_sqm_18)))
gg_reshist(lm((1/(density_sqm_18)) ~ City_dist , data = density_18 ), bins=20)

# go with a non-parametric test: Kruskal-Wallace rank sum test
```


######## Kruskal-Wallace rank sum test
```{r}
kruskal.test(density_sqm_18 ~  City_dist , data = density_18)
# Plant density does not significantly change along the gradient.

# same insignificant results if using ANOVA with log-transformed data too.
car::Anova(lm(log(density_sqm_18) ~  City_dist , data = density_18))

```

####### With transects
######## Diagnostics- WHICH TEST TO USE?
```{r}

# First, remove rural points to avoid collinearity.
density_18_urban <- subset(density_18, Transect_ID == "North" | Transect_ID == "South")

urbdensity_lm <- lm(density_sqm_18 ~ City_dist * Transect_ID, data = density_18_urban)

par(mfrow=c(2,2))
plot(urbdensity_lm)

ggqqplot(density_18_urban$density_sqm_18)
## Data points don't fit in envelope towards right margin.

# Histogram
gg_reshist(urbdensity_lm, bins=20)
# very right-skewed

## try transformation.
##################################

## tried square, cube + roots: not strong enough
par(mfrow=c(2,2))
plot(lm(log(density_sqm_18^(1/10) ~ City_dist* Transect_ID, data = density_18_urban )))
ggqqplot(density_18_urban$density_sqm_18^(1/10))
gg_reshist(lm(density_sqm_18^(1/10) ~ City_dist* Transect_ID, data = density_18_urban ), bins=20)

## tried log(x): makes it into a bimodal distribution...
par(mfrow=c(2,2))
plot(lm(log(density_sqm_18) ~ City_dist* Transect_ID , data = density_18_urban ))
ggqqplot(log(density_18_urban$density_sqm_18))
gg_reshist(lm(log(density_sqm_18) ~ City_dist* Transect_ID , data = density_18_urban ), bins=20)

# tried reciprocal transformation (1/x): still have ~20 data points not fitting
par(mfrow=c(2,2))
plot(lm(1/(density_sqm_18) ~ City_dist* Transect_ID , data = density_18_urban ))
ggqqplot(1/(density_18_urban$density_sqm_18))
gg_reshist(lm(1/(density_sqm_18) ~ City_dist* Transect_ID, data = density_18_urban ), bins=20)

# go with a non-parametric test?
```


######### ANOVA
```{r}
# car::Anova(lm(density_sqm_18	~ City_dist * Transect_ID, data = density_18_urban))
# # 3-way interaction not significant, so let's look at lower-level interactions and main effects.
# 


```


##### Export ANOVAs
###### xtableList
```{r}
xtable(p.3,
           digits = c(0,3,0,3),
           caption = "$(1|Patch_ID/Plant_Num/Inflor) $ + Citydist - ONLY 2018")

kable(p.3,
      format = "latex", 
      caption = "kableExtra to format spanning columns",
      digits=c(0,3,0,3)) %>%
  kable_styling( full_width=F) %>%
  add_footnote(c("Note, means and medians are often the same with this data."))
```

###### City_dist
####### One csv- lm/glm
```{r}

# Start a sink file with a CSV extension
sink('Figures_Tables/Q1_Q3_ANOVA/lm_glm_ANOVA_citydist.csv')

#### Pollinaria ####
## table 1
cat('Pollinaria- Q1')
cat('\n')
cat('P ~ city_dist * year')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.poll.gr.1))
cat('\n')
write.csv(r.squaredGLMM(lm.poll.gr.1))
cat('\n')
cat('Main Effect')
write.csv(lm.poll.gr.1_anova)
cat('\n')

## table 2
cat('Pollinaria- Q1')
cat('\n')
cat('P ~ city_dist + year')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.poll.gr.2))
cat('\n')
write.csv(r.squaredGLMM(lm.poll.gr.2))
cat('\n')
cat('Main Effect')
write.csv(lm.poll.gr.2_anova)
cat('\n')

## table 3
cat('Pollinaria- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect_ID + Year:City_dist + Year:Transect_ID + City_dist:Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.poll.subt.2))
cat('\n')
write.csv(r.squaredGLMM(lm.poll.subt.2))
cat('\n')
cat('Main Effect')
write.csv(lm.poll.subt.2_anova)
cat('\n')

## table 4
cat('Pollinaria- Q3')
cat('\n')
cat('P ~  Year + City_dist + Transect_ID + Year:Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.poll.subt.3))
cat('\n')
write.csv(r.squaredGLMM(lm.poll.subt.3))
cat('\n')
cat('Main Effect')
write.csv(lm.poll.subt.3_anova)
cat('\n')

## table 5
cat('Pollinaria- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.poll.subt.4))
cat('\n')
write.csv(r.squaredGLMM(lm.poll.subt.4))
cat('\n')
cat('Main Effect')
write.csv(lm.poll.subt.4_anova)
cat('\n')
cat('\n')

#### Pods ####
## table 1
cat('Follicles- Q1')
cat('\n')
cat('p ~ Year * City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.pods.gr.1))
cat('\n')
write.csv(r.squaredGLMM(lm.pods.gr.1))
cat('\n')
cat('Main Effect')
write.csv(lm.pods.gr.1_anova)
cat('\n')

## table 2
cat('Follicles- Q1')
cat('\n')
cat('p ~ Year + City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.pods.gr.2))
cat('\n')
write.csv(r.squaredGLMM(lm.pods.gr.2))
cat('\n')
cat('Main Effect')
write.csv(lm.pods.gr.2_anova)
cat('\n')

## table 3
cat('Follicles- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.pods.subt.3))
cat('\n')
write.csv(r.squaredGLMM(lm.pods.subt.3))
cat('\n')
cat('Main Effect')
write.csv(lm.pods.subt.3_anova)
cat('\n')
cat('\n')


#### Peduncles ####
## table 1
cat('Peduncles- Q1')
cat('\n')
cat('p ~ Year * City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.peds.gr.1))
cat('\n')
write.csv(r.squaredGLMM(lm.peds.gr.1))
cat('\n')
cat('Main Effect')
write.csv(lm.peds.gr.1_anova)
cat('\n')

## table 2
cat('Peduncles- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.peds.subt.3))
cat('\n')
write.csv(r.squaredGLMM(lm.peds.subt.3))
cat('\n')
cat('Main Effect')
write.csv(lm.peds.subt.3_anova)
cat('\n')
cat('\n')

#### Height ####
## table 1
cat('Height- Q1')
cat('\n')
cat('p ~ Year * City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.height.gr.1))
cat('\n')
write.csv(r.squaredGLMM(lm.height.gr.1))
cat('\n')
cat('Main Effect')
write.csv(lm.height.gr.1_anova)
cat('\n')

## table 2
cat('Height- Q1')
cat('\n')
cat('p ~ Year + City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.height.gr.2))
cat('\n')
write.csv(r.squaredGLMM(lm.height.gr.2))
cat('\n')
cat('Main Effect')
write.csv(lm.height.gr.2_anova)
cat('\n')

## table 3
cat('Height- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.height.subt.3))
cat('\n')
write.csv(r.squaredGLMM(lm.height.subt.3))
cat('\n')
cat('Main Effect')
write.csv(lm.height.subt.3_anova)
cat('\n')
cat('\n')

#### Follicles per Inflorescence ####
## table 1
cat('Follicles per Inflorescence- Q1')
cat('\n')
cat('p ~ Year * City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.podperped.gr.1))
cat('\n')
write.csv(r.squaredGLMM(lm.podperped.gr.1))
cat('\n')
cat('Main Effect')
write.csv(lm.podperped.gr.1_anova)
cat('\n')

## table 2
cat('Follicles per Inflorescence- Q1')
cat('\n')
cat('p ~ Year + City_dist')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.podperped.gr.2))
cat('\n')
write.csv(r.squaredGLMM(lm.podperped.gr.2))
cat('\n')
cat('Main Effect')
write.csv(lm.podperped.gr.2_anova)
cat('\n')

## table 3
cat('Follicles per Inflorescence- Q3')
cat('\n')
cat('P ~ Year + City_dist + Transect')
cat('\n')
cat('AIC: ')
write.csv(AIC(lm.podperped.subt.3))
cat('\n')
write.csv(r.squaredGLMM(lm.podperped.subt.3))
cat('\n')
cat('Main Effect')
write.csv(lm.podperped.subt.3_anova)
cat('\n')
cat('\n')


##### Close the sink ####
sink()

```

###### Urb_score
####### One csv- lm/glm
```{r}

# Start a sink file with a CSV extension
sink('Figures_Tables/Q1_Q3_ANOVA/lm_glm_ANOVA_urbscore.csv')

#### Pollinaria ####
## table 1
cat('Pollinaria- Q1')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score * Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_poll_glm_gradient_1))
cat('\n')
write.csv(r.squaredGLMM(u_poll_glm_gradient_1))
cat('\n')
cat('Main Effect')
write.csv(u_poll_glm_gradient_1_anova)
cat('\n')


## table 2
cat('Pollinaria- Q1')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num/Inflor) + Urb_score + Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_poll_glm_gradient_2))
cat('\n')
write.csv(r.squaredGLMM(u_poll_glm_gradient_2))
cat('\n')
cat('Main Effect')
write.csv(u_poll_glm_gradient_2_anova)
cat('\n')

## table 3
cat('Pollinaria- Q3')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num/Inflor) + Year + Urb_score + Transect_ID + Year:Urb_score + Year:Transect_ID + Urb_score:Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_poll_glm_subtr_2))
cat('\n')
write.csv(r.squaredGLMM(u_poll_glm_subtr_2))
cat('\n')
cat('Main Effect')
write.csv(u_poll_glm_subtr_2_anova)
cat('\n')

## table 4
cat('Pollinaria- Q3')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num/Inflor) + Year + Urb_score + Transect_ID + Year:Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_poll_glm_subtr_3))
cat('\n')
write.csv(r.squaredGLMM(u_poll_glm_subtr_3))
cat('\n')
cat('Main Effect')
write.csv(u_poll_glm_subtr_3_anova)
cat('\n')
cat('\n')

#### Pods ####
## table 1
cat('Follicles- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score * Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_pod_glm_gradient_1))
cat('\n')
write.csv(r.squaredGLMM(u_pod_glm_gradient_1))
cat('\n')
cat('Main Effect')
write.csv(u_pod_glm_gradient_1_anova)
cat('\n')

# Table 2
cat('Follicles- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_pod_glm_gradient_2))
cat('\n')
write.csv(r.squaredGLMM(u_pod_glm_gradient_2))
cat('\n')
cat('Main Effect')
write.csv(u_pod_glm_gradient_2_anova)
cat('\n')

## table 3
cat('Follicles- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year + Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_pod_glm_subtr_3))
cat('\n')
write.csv(r.squaredGLMM(u_pod_glm_subtr_3))
cat('\n')
cat('Main Effect')
write.csv(u_pod_glm_subtr_3_anova)
cat('\n')
cat('\n')

#### Peduncles ####
## table 1
cat('Peduncles- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score * Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_ped_glm_gradient_1))
cat('\n')
write.csv(r.squaredGLMM(u_ped_glm_gradient_1))
cat('\n')
cat('Main Effect')
write.csv(u_ped_glm_gradient_1_anova)
cat('\n')

## table 2
cat('Peduncles- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_ped_glm_gradient_2))
cat('\n')
write.csv(r.squaredGLMM(u_ped_glm_gradient_2))
cat('\n')
cat('Main Effect')
write.csv(u_ped_glm_gradient_2_anova)
cat('\n')

## table 3
cat('Peduncles- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year + Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_ped_glm_subtr_3))
cat('\n')
write.csv(r.squaredGLMM(u_ped_glm_subtr_3))
cat('\n')
cat('Main Effect')
write.csv(u_ped_glm_subtr_3_anova)
cat('\n')
cat('\n')

#### Height ####
## table 1
cat('Height- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score * Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_height_glm_gradient_1))
cat('\n')
write.csv(r.squaredGLMM(u_height_glm_gradient_1))
cat('\n')
cat('Main Effect')
write.csv(u_height_glm_gradient_1_anova)
cat('\n')

## table 2
cat('Height- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_height_glm_gradient_2))
cat('\n')
write.csv(r.squaredGLMM(u_height_glm_gradient_2))
cat('\n')
cat('Main Effect')
write.csv(u_height_glm_gradient_2_anova)
cat('\n')

## table 3
cat('Height- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year + Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_height_glm_subtr_3))
cat('\n')
write.csv(r.squaredGLMM(u_height_glm_subtr_3))
cat('\n')
cat('Main Effect')
write.csv(u_height_glm_subtr_3_anova)
cat('\n')
cat('\n')


#### Follicles per Inflorescence ####
## table 1
cat('Follicles per Inflorescence- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score * Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_podperped_glm_gradient_1))
cat('\n')
write.csv(r.squaredGLMM(u_podperped_glm_gradient_1))
cat('\n')
cat('Main Effect')
write.csv(u_podperped_glm_gradient_1_anova)
cat('\n')

## table 2
cat('Follicles per Inflorescence- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score + Year')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_podperped_glm_gradient_2))
cat('\n')
write.csv(r.squaredGLMM(u_podperped_glm_gradient_2))
cat('\n')
cat('Main Effect')
write.csv(u_podperped_glm_gradient_2_anova)
cat('\n')

## table 3
cat('Follicles per Inflorescence- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score * Year * Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_podperped_glm_subtr_1))
cat('\n')
write.csv(r.squaredGLMM(u_podperped_glm_subtr_1))
cat('\n')
cat('Main Effect')
write.csv(u_podperped_glm_subtr_1_anova)
cat('\n')

## table 4
cat('Follicles per Inflorescence- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Urb_score:Year:Transect_ID + Urb_score + Year + Transect_ID')
cat('\n')
cat('AIC: ')
write.csv(AIC(u_podperped_glm_subtr_2))
cat('\n')
write.csv(r.squaredGLMM(u_podperped_glm_subtr_2))
cat('\n')
cat('Main Effect')
write.csv(u_podperped_glm_subtr_2_anova)
cat('\n')
cat('\n')

##### Close the sink ####
sink()

```


####### One csv- lmer/glmer - plant/inflor-level means
```{r}

# Start a sink file with a CSV extension
sink('lmer_glmer_Inflorplantlevelmeans_ANOVA.csv')

#### Pollinaria ####
## table 1
cat('Pollinaria- Inflorescence means- Q1')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num) + City_dist + Year')
cat('\n')
cat('Main Effect')
write.csv(z1.1)
cat('\n')

## table 2
cat('Pollinaria- Inflorescence means- Q3')
cat('\n')
cat('p ~ (1|Patch_ID/Plant_Num) + City_dist * Year * Transect_ID')
cat('\n')
cat('Main Effect')
write.csv(z2.1)
cat('\n')

## table 3
cat('Pollinaria- Plant means- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + City_dist + Year')
cat('\n')
cat('Main Effect')
write.csv(z3.1)
cat('\n')

## table 4
cat('Pollinaria- Plant means- Q3')
cat('Loose p = 0.05 cutoff')
cat('\n')
cat('p ~ Poll_rm_per_plant ~ (1|Patch_ID) + City_dist:Year + Transect_ID:Year + Transect_ID + City_dist + Year')
cat('\n')
cat('Main Effect')
write.csv(z4.22)
cat('\n')

## table 5
cat('Pollinaria- Plant means- Q3')
cat('Strict p = 0.05 cutoff')
cat('\n')
cat('p ~ Poll_rm_per_plant ~ (1|Patch_ID) + Year')
cat('\n')
cat('Main Effect')
write.csv(z4.5)
cat('\n')
cat('\n')

#### Pods ####
## table 1
cat('Follicles- Plant means- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Year')
cat('\n')
cat('Main Effect')
write.csv(y1.21)
cat('\n')

## table 2
cat('Follicles- Plant means- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + City_dist * Year * Transect_ID')
cat('\n')
cat('Main Effect')
write.csv(y2.1)
cat('\n')
cat('\n')


#### Peduncles ####
## table 1
cat('Peduncles- Plant means- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + City_dist * Year')
cat('\n')
cat('Main Effect')
write.csv(x1.1)
cat('\n')

## table 2
cat('Peduncles- Plant means- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + City_dist')
cat('\n')
cat('Main Effect')
write.csv(x2.61)
cat('\n')
cat('\n')

#### Height ####
## table 1
cat('Height- Plant means- same as lmer csv- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + year')
cat('\n')
cat('Main Effect')
write.csv(w1.21)
cat('\n')

## table 2
cat('Height- Plant means- same as lmer csv- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) * City_dist * Year * Transect_ID')
cat('\n')
cat('Main Effect')
write.csv(w2.1)
cat('\n')
cat('\n')

#### Follicles per Inflorescence ####
## table 1
cat('Follicles per Inflorescence- Plant means- Q1')
cat('\n')
cat('p ~ (1|Patch_ID) + Year')
cat('\n')
cat('Main Effect')
write.csv(v1.21)
cat('\n')

## table 2
cat('Follicles per Inflorescence- Plant means- Q3')
cat('\n')
cat('p ~ (1|Patch_ID) + Transect_ID:Year + City_dist:Year + Year + Transect_ID + City_dist')
cat('\n')
cat('Main Effect')
write.csv(v2)
cat('\n')
cat('\n')


##### Close the sink ####
sink()

```


#### Comparing yearly means for variables
##### Pollinia- yearly differences (lm)
###### All data
```{r}
urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii

# 2018
po.1 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_18_19 %>% filter(Year == '2018'))
coeffs.po.1 = coefficients(po.1); coeffs

rural_mean = coeffs.po.1[1] + coeffs.po.1[2]*rural_terminus 
rural_mean # mean no. pollinia removed
rural_mean/5 # percentage of pollinia removed

urban_mean = coeffs.po.1[1] + coeffs.po.1[2]*urban_terminus 
urban_mean # mean no. pollinia removed
urban_mean/5 # percentage of pollinia removed

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2018 = coeffs.po.1[1] + coeffs.po.1[2]*midpoint 
central_mean_2018


# 2019
po.2 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_18_19 %>% filter(Year == '2019'))
coeffs.po.2 = coefficients(po.2); coeffs

rural_mean = coeffs.po.2[1] + coeffs.po.2[2]*rural_terminus 
rural_mean
rural_mean/5

urban_mean = coeffs.po.2[1] + coeffs.po.2[2]*urban_terminus 
urban_mean
urban_mean/5

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2019 = coeffs.po.2[1] + coeffs.po.2[2]*midpoint 
central_mean_2019


#### COMPARE 2018-2019
# AVG DIFFERENCE:
(central_mean_2018 - central_mean_2019)/(0.5*(central_mean_2018 + central_mean_2019))
# 2018 had 24% more poll removed than 2019


```

###### Transects (urban data)
```{r}
urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii

# 2018
## North
upo.1 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_18 %>% filter(Transect_ID == 'North'))
coeffs.upo.1 = coefficients(upo.1)

rural_mean = coeffs.upo.1[1] + coeffs.upo.1[2]*rural_terminus 
rural_mean # mean no. pollinia removed
rural_mean/5 # percentage of pollinia removed

urban_mean = coeffs.upo.1[1] + coeffs.upo.1[2]*urban_terminus 
urban_mean # mean no. pollinia removed
urban_mean/5 # percentage of pollinia removed

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2018_N = coeffs.upo.1[1] + coeffs.upo.1[2]*midpoint 
central_mean_2018_N


# South
upo.2 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_18 %>% filter(Transect_ID == 'South'))
coeffs.upo.2 = coefficients(upo.2)

rural_mean = coeffs.upo.2[1] + coeffs.upo.2[2]*rural_terminus 
rural_mean
rural_mean/5

urban_mean = coeffs.upo.2[1] + coeffs.upo.2[2]*urban_terminus 
urban_mean
urban_mean/5

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2018_S = coeffs.upo.2[1] + coeffs.upo.2[2]*midpoint 
central_mean_2018_S


#### COMPARE 2018 NORTH-SOUTH
# AVG DIFFERENCE:
(central_mean_2018_N - central_mean_2018_S)/(0.5*(central_mean_2018_N + central_mean_2018_S))
# 2018 North had 76% fewer poll removed than South


# - - - - - - - - - - - - - - - - - - - - - - -


# 2019
## North
upo.3 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_19 %>% filter(Transect_ID == 'North'))
coeffs.upo.3 = coefficients(upo.3)

rural_mean = coeffs.upo.3[1] + coeffs.upo.3[2]*rural_terminus 
rural_mean # mean no. pollinia removed
rural_mean/5 # percentage of pollinia removed

urban_mean = coeffs.upo.3[1] + coeffs.upo.3[2]*urban_terminus 
urban_mean # mean no. pollinia removed
urban_mean/5 # percentage of pollinia removed

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2019_N = coeffs.upo.3[1] + coeffs.upo.3[2]*midpoint 
central_mean_2019_N


# South
upo.4 <- lm(Average_Pollinia	~ City_dist, data = AvgVars_notNA_Poll_19 %>% filter(Transect_ID == 'South'))
coeffs.upo.4 = coefficients(upo.4)

rural_mean = coeffs.upo.4[1] + coeffs.upo.4[2]*rural_terminus 
rural_mean
rural_mean/5

urban_mean = coeffs.upo.4[1] + coeffs.upo.4[2]*urban_terminus 
urban_mean
urban_mean/5

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2019_S = coeffs.upo.4[1] + coeffs.upo.4[2]*midpoint 
central_mean_2019_S


#### COMPARE 2019 NORTH-SOUTH
# AVG DIFFERENCE:
(central_mean_2019_N - central_mean_2019_S)/(0.5*(central_mean_2019_N + central_mean_2019_S))
# 2019 North had 33% fewer poll removed than South








#### COMPARE 2018-2019
# AVG DIFFERENCE:
(central_mean_2018 - central_mean_2019)/(0.5*(central_mean_2018 + central_mean_2019))
# 2018 had 24% more poll removed than 2019

# NORTH DIFFERENCE:
(central_mean_2018_N - central_mean_2019_N)/(0.5*(central_mean_2018_N + central_mean_2019_N))
# 2018-North had 44% more  poll removed than 2019-north

# South DIFFERENCE:
(central_mean_2018_S - central_mean_2019_S)/(0.5*(central_mean_2018_S + central_mean_2019_S))
# 2018-South had 86% more  poll removed than 2019-south
```


##### Peduncles/Inflors -transects
```{r}

urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii


# 2018
inf.1 <- lm(Peduncles_sq	~ City_dist, data = fertile_pops_all_notNApeds_urban %>% filter(Year == '2018'))
coeffs.inf.1 = coefficients(inf.1)

rural_mean = coeffs.inf.1[1] + coeffs.inf.1[2]*rural_terminus 
rural_mean # mean no. inflors

urban_mean = coeffs.inf.1[1] + coeffs.inf.1[2]*urban_terminus 
urban_mean # mean no. inflors

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2018 = coeffs.inf.1[1] + coeffs.inf.1[2]*midpoint 
central_mean_2018


# AVG DIFFERENCE FROM URBAN TO MIDPOINT-URBAN TERMINUS:
(urban_mean - central_mean_2018)/(0.5*(urban_mean + central_mean_2018))




# 2019
inf.2 <- lm(Peduncles_sq	~ City_dist, data = fertile_pops_all_notNApeds_urban %>% filter(Year == '2019'))
coeffs.inf.2 = coefficients(inf.2)

rural_mean = coeffs.inf.2[1] + coeffs.inf.2[2]*rural_terminus 
rural_mean # mean no. inflors

urban_mean = coeffs.inf.2[1] + coeffs.inf.2[2]*urban_terminus 
urban_mean # mean no. inflors

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN # POLLINIA REMOVED
central_mean_2019 = coeffs.inf.2[1] + coeffs.inf.2[2]*midpoint 
central_mean_2019


# AVG DIFFERENCE FROM URBAN TO MIDPOINT-URBAN TERMINUS:
(urban_mean - central_mean_2019)/(0.5*(urban_mean + central_mean_2019))


# #### COMPARE 2018-2019
# # AVG DIFFERENCE:
# (central_mean_2018 - central_mean_2019)/(0.5*(central_mean_2018 + central_mean_2019))
# # 2018 had 24% more poll removed than 2019


```

##### Foll per inflor- yearly differences (lm)
```{r}
urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii

# 2018
fi.1 <- lm(pods_per_ped_sqrt	~ City_dist, data = fertile_pops_all_podsperped %>% filter(Year == '2018'))
coeffs.fi.1 = coefficients(fi.1)

rural_mean = coeffs.fi.1[1] + coeffs.fi.1[2]*rural_terminus 
rural_mean # mean no. follicles/inflor

urban_mean = coeffs.fi.1[1] + coeffs.fi.1[2]*urban_terminus 
urban_mean # mean no. follicles/inflor

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN #  follicles/inflor
central_mean_2018 = coeffs.fi.1[1] + coeffs.fi.1[2]*midpoint 
central_mean_2018


# 2019
fi.2 <- lm(pods_per_ped_sqrt	~ City_dist, data = fertile_pops_all_podsperped %>% filter(Year == '2019'))
coeffs.fi.2 = coefficients(fi.2)

rural_mean = coeffs.fi.2[1] + coeffs.fi.2[2]*rural_terminus 
rural_mean

urban_mean = coeffs.fi.2[1] + coeffs.fi.2[2]*urban_terminus 
urban_mean

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN #  follicles/inflor
central_mean_2019 = coeffs.fi.2[1] + coeffs.fi.2[2]*midpoint 
central_mean_2019


#### COMPARE 2018-2019
# AVG DIFFERENCE:
(central_mean_2018 - central_mean_2019)/(0.5*(central_mean_2018 + central_mean_2019))
# 2018 had 24% more follicles/inflor than 2019


```


### Figures
#### Main text
##### Gradient regressions
```{r}
## CITY_DIST -----------------------
# POLLINIA --------
Q1_reg_poll <- ggplot(AvgVars_notNA_Poll_18_19, aes(x = City_dist, y = Average_Pollinia, shape=Year)) + 
  labs(x = "Distance to urban center (km)", 
    y = "Pollinaria Removed") +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=.15, se = T) +
  scale_y_continuous(breaks=c(0,1,2,3,4,5), limits=c(0,5)) +
  labs( color="Year", shape="Year") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_poll


# PODS --------
Q1_reg_pod <- ggplot(fertile_pops_all_notNApods, aes(x = City_dist, y = Viable_Pods_sqrt, shape=Year)) +
  labs(x = "Distance to urban center (km)",
       y = expression(Follicles^{0.5})) +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=0.15, se = T) +
  scale_y_continuous(limits=c(0,4)) +
  labs(color="Year", size = "Year") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
 text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_pod



# PEDUNCLES --------
Q1_reg_ped <- ggplot(fertile_pops_all_notNApeds, aes(x = City_dist, y = Peduncles_sq, shape=Year)) +
  labs(x = "Distance to urban center (km)",
       y = expression(Inflorescences^{2})) +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=0.15, se = T) +
  scale_y_continuous(limits=c(0,200)) +
  labs(color="Year", size = "Year") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
     text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_ped

# FOLLICLES PER INFLOR --------
Q1_reg_follperinflor <- ggplot(fertile_pops_all_podsperped, aes(x = City_dist, y = pods_per_ped_sqrt, shape=Year)) +
  labs(x = "Distance to urban center (km)",
    y = expression(Follicles/Inflorescence^{0.5})) +
  geom_point(aes(color = Year, shape = Year), size=2) +
  scale_shape(solid = F)+
  scale_y_continuous(limits=c(0,1.5)) +
  geom_smooth(aes(colour=Year, shape=Year, fill=Year),size=0.75, method = lm, alpha=0.15, se = T) +
  labs(color="Year", size="Year") +
  labs(linetype="Year", shape = "Year") +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_follperinflor

# PLANT DENSITY AT SITE (not included in composite figure, below) --------
Q1_reg_density <- ggplot(density_18, aes(x = City_dist, y = density_sqm_18)) +
  labs( x = "Distance to urban center (km)", y = "Plant density") +
  geom_point(size=2) +
  scale_shape(solid = F)+
  geom_smooth(size=0.75, method = lm, alpha=0.15, se = T) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_density


## URB_SCORE -------------------------
# POLLINIA --------
Q1_reg_poll_u <- ggplot(urb_scores_poll_all, aes(x = Urb_score, y = Average_Pollinia, shape=Year)) +
  labs(
    # x = "Urbanization Score",
    y = "Pollinaria Removed") +
  scale_x_reverse() +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=.15, se = T) +
  scale_y_continuous(breaks=c(0,1,2,3,4,5), limits=c(0,5)) +
  labs( color="Year", shape="Year") +
  theme(
    legend.position = "none",
    axis.title.x = element_blank(),
    # legend.position = c(.99, .99),
    # legend.justification = c("right", "top"),
    # legend.box = 'horizontal',
    # legend.box.just = "right",
    # legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    # axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
    # legend.key = element_rect(fill = NA)
    )
Q1_reg_poll_u


# PODS --------
Q1_reg_pod_u <- ggplot(urb_scores_pods_all, aes(x = Urb_score, y = Viable_Pods_sqrt, shape=Year)) + labs(
  # x = "Urbanization Score",
    y = expression(Follicles^{0.5})) +
  scale_x_reverse() +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=0.15, se = T) +
  scale_y_continuous(limits=c(0,4)) +
  labs(color="Year", size = "Year") +
  theme(
    legend.position = "none",
        axis.title.x = element_blank(),
 #    legend.position = c(.99, .99),
 #    legend.justification = c("right", "top"),
 #    legend.box = 'horizontal',
 #    legend.box.just = "right",
 #    legend.margin = margin(5,5,5,5),
     text = element_text(size=14),
 #    axis.title.x = element_blank(),
     panel.background = element_blank(),
     axis.line = element_line(colour = "black")
 #    legend.key = element_rect(fill = NA)
 )
Q1_reg_pod_u



# PEDUNCLES --------
Q1_reg_ped_u <- ggplot(urb_scores_peds_all, aes(x = Urb_score, y = Peduncles_sq, shape=Year)) + 
  labs(
    # x = "Urbanization Score",
       y = expression(Inflorescences^{2})) +
  scale_x_reverse() +
  geom_point(aes(shape=Year, color=Year),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Year, color=Year, fill=Year), size=0.75, method = lm, alpha=0.15, se = T) +
  scale_y_continuous(limits=c(0,200)) +
  labs(color="Year", size = "Year") +
  theme(
    legend.position = "none",
        axis.title.x = element_blank(),
    # legend.position = c(.99, .99),
    # legend.justification = c("right", "top"),
    # legend.box = 'horizontal',
    # legend.box.just = "right",
    # legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    # axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
    # legend.key = element_rect(fill = NA)
    )
Q1_reg_ped_u

# FOLLICLES PER INFLOR --------
Q1_reg_follperinflor_u <- ggplot(urb_scores_podperped_all, aes(x = Urb_score, y = pods_per_ped, shape=Year)) +
  labs(
  # x = "Urbanization Score",
       y = "Follicles/Inflorescence") +
  scale_x_reverse() +
  geom_point(aes(color = Year, shape = Year), size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(colour=Year, shape=Year, fill=Year),size=0.75, method = lm, alpha=0.15, se = T) +
  labs(color="Year", size="Year") +
  labs(linetype="Year",  shape = "Year") +
  theme(legend.position = "none",
            axis.title.x = element_blank(),
    # legend.position = c(.99, .99),
    # legend.justification = c("right", "top"),
    # legend.box.just = "right",
    # legend.box = 'horizontal',
    # legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    # axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
    # legend.key = element_rect(fill = NA)
    )
Q1_reg_follperinflor_u



## PLOTS ------
library(ggpubr)
Q1_regressions_citydist <- ggarrange(Q1_reg_ped , Q1_reg_poll, Q1_reg_pod,  Q1_reg_follperinflor +
                            font("x.text"),
                            ncol = 4,
                            nrow = 1,
                            align = "hv",
                            labels = list("A", "B", "C", "D"),
                            font.label = (size =16),
                            common.legend = T,
                            legend = "top") %T>%
  plot

Q1_regressions_urbscore <- ggarrange(Q1_reg_ped_u, Q1_reg_poll_u, Q1_reg_pod_u,  Q1_reg_follperinflor_u +
                            font("x.text"),
                            ncol = 4,
                            nrow = 1,
                            align = "hv",
                            labels = list("E", "F", "G", "H"),
                            font.label = (size =16),
                            common.legend = F) %T>%
  plot

city_plots <- annotate_figure(Q1_regressions_citydist, bottom = text_grob("Distance to Urban Center (km)", size=14))
urbscore_plots <- annotate_figure(Q1_regressions_urbscore, bottom = text_grob("Urbanization Score", size=14))

city_plots/urbscore_plots

dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/Q1_Gradient/Gradient_regressions.pdf", width = 12, height = 8)
```



##### Urban subtransect regressions
```{r}
## CITY_DIST -----------------------
# POLLINIA-----
Q2_reg_poll_subtr <- ggplot(AvgVars_notNA_Poll_18_19_urban,
                            aes(x = City_dist, y = Average_Pollinia,
                                group = interaction(Year,Transect_ID),
                                color=interaction(Year,Transect_ID),
                                linetype=interaction(Year,Transect_ID),
                                shape=interaction(Year,Transect_ID))) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_y_continuous(breaks=c(0,1,2,3), limits=c(0,3)) +
  labs(x = "Distance to City Center (km)",
       y = "Pollinaria Removed",
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line") )

Q2_reg_poll_subtr

# PODS-----
Q2_reg_pod_subtr <- ggplot(fertile_pops_all_notNApods_urban,
                           aes(x = City_dist, y = Viable_Pods_sqrt,
                               group=interaction(Year,Transect_ID),
                               color=interaction(Year,Transect_ID),
                               linetype=interaction(Year,Transect_ID),
                               shape=interaction(Year,Transect_ID))) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  labs(x = "Distance to City Center (km)",
       y = expression(Follicles^{0.5}) ,
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
 text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line") )

Q2_reg_pod_subtr


# PEDUNCLES----
Q2_reg_ped_subtr <- ggplot(fertile_pops_all_notNApeds_urban,
                           aes(x = City_dist,
                               y = Peduncles_sq,
                               group=interaction(Year,Transect_ID),
                               color=interaction(Year,Transect_ID),
                               linetype=interaction(Year,Transect_ID),
                               shape=interaction(Year,Transect_ID)
                                 )) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_y_continuous(limits=c(0,200)) +
  labs(x = "Distance to City Center (km)",
       y = expression(Inflorescences^{0.5}),
    color = "Year, Subtransect",
    shape = "Year, Subtransect",
    linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
     text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line") )

Q2_reg_ped_subtr

# FOLLICLES PER INFLORESCENCE----
Q2_reg_follperinfl_subtr <-  ggplot(fertile_pops_all_podsperped_urban,
                                   aes(x = City_dist,
                                       y = pods_per_ped_sqrt, 
                                       group=interaction(Year,Transect_ID),
                                       color=interaction(Year,Transect_ID),
                                       linetype=interaction(Year,Transect_ID),
                                       shape=interaction(Year,Transect_ID))) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  labs(x = "Distance to City Center (km)",
    y = expression(Follicles/Inflorescence^{0.5}),
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line"))
# +  guides(colour = guide_legend(override.aes = list(size=7)))
Q2_reg_follperinfl_subtr


## URB_SCORE -------------------------
# POLLINIA-----
Q2_reg_poll_subtr_u <- ggplot(urb_scores_poll, aes(Urb_score, Average_Pollinia,
                                 group=interaction(Year,Transect_ID),
                                 color=interaction(Year,Transect_ID),
                                 linetype=interaction(Year,Transect_ID),
                                 shape=interaction(Year,Transect_ID)
                                 )) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_x_reverse() +
  scale_y_continuous(breaks=c(0,1,2,3), limits=c(0,3)) +
  labs(x = "Urbanization Score",
       y = "Pollinaria Removed",
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        text = element_text(size=14),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))
Q2_reg_poll_subtr_u

# PODS-----
Q2_reg_pod_subtr_u <- ggplot(urb_scores_pods, aes(Urb_score, Viable_Pods_sqrt,
                                 group=interaction(Year,Transect_ID),
                                 color=interaction(Year,Transect_ID),
                                 linetype=interaction(Year,Transect_ID),
                                 shape=interaction(Year,Transect_ID)
                                 )) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_x_reverse() +
  labs(x = "Urbanization Score",
       y = expression(Follicles^{0.5}) ,
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        text = element_text(size=14),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))
Q2_reg_pod_subtr_u


# PEDUNCLES----
Q2_reg_ped_subtr_u <- ggplot(urb_scores_peds, aes(Urb_score, Peduncles_sq,
                                 group=interaction(Year,Transect_ID),
                                 color=interaction(Year,Transect_ID),
                                 linetype=interaction(Year,Transect_ID),
                                 shape=interaction(Year,Transect_ID)
                                 )) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_x_reverse() +
  scale_y_continuous(limits=c(0,200)) +
  labs(x = "Urbanization Score",
       y =expression(Inflorescences^{0.5}),
    color = "Year, Subtransect",
    shape = "Year, Subtransect",
    linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        text = element_text(size=14),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))
Q2_reg_ped_subtr_u

# FOLLICLES PER INFLORESCENCE----
Q2_reg_follperinfl_subtr_u <- ggplot(urb_scores_podperped, aes(Urb_score, pods_per_ped,
                                 group=interaction(Year,Transect_ID),
                                 color=interaction(Year,Transect_ID),
                                 linetype=interaction(Year,Transect_ID),
                                 shape=interaction(Year,Transect_ID)
                                 )) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  scale_x_reverse() +
  labs(x = "Urbanization Score",
       y = "Follicles/Inflorescence",
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        text = element_text(size=14),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))

Q2_reg_follperinfl_subtr_u



# ggplot(urb_scores_podperped, aes(x = Urb_score, y = pods_per_ped,
#                                  color = Year,
#                                  shape = Year,
#                                  linetype = Transect_ID,
#                                  fill = Transect_ID)) +
#   labs(x = "Urbanization Score", 
#     y = "Follicles/Inflorescence",
#     shape = 'Year', linetype = 'Subtransect', color = 'Year', fill = 'Subtransect') +
#   geom_point(size=2) +
#     scale_x_reverse() +
#   geom_smooth(method = lm, alpha=0.15, se = F) +
#    theme( #legend.position = "none",
#     # axis.title.x = element_blank(),
#     legend.box = 'horizontal',
#     text = element_text(size=14),
#     panel.background = element_blank(),
#     axis.line = element_line(colour = "black")) +
#   scale_linetype_discrete(name  ="Subtransect",
#                            breaks=c("North", "South"),
#                            labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
#   scale_shape_discrete(name  ="Subtransect",
#                            breaks=c("North", "South"),
#                            labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
#   scale_color_discrete(name  ="Year",
#                            breaks=c("2018", "2019"),
#                            labels=c("2018", "2019")) +
#   scale_fill_discrete(name  ="Subtransect",
#                            breaks=c("North", "South"),
#                            labels=c("Urban: Non-Corridor", "Urban: Corridor"))



# ggplot(urb_scores_podperped, aes(x = Urb_score, y = pods_per_ped,
#                                  color = Year,
#                                  shape = Year,
#                                  linetype = Transect_ID,
#                                  fill = Transect_ID)) +
#   labs(x = "Urbanization Score", 
#     y = "Follicles/Inflorescence",
#     shape = 'Year', linetype = 'Subtransect', color = 'Year', fill = 'Subtransect') +
#   geom_point(size=2) +
#     scale_x_reverse() +
#   geom_smooth(method = lm, alpha=0.15, se = F) +
#    theme( #legend.position = "none",
#     # axis.title.x = element_blank(),
#     legend.box = 'horizontal',
#     text = element_text(size=14),
#     panel.background = element_blank(),
#     axis.line = element_line(colour = "black")) +
#   scale_linetype_discrete(name  ="Subtransect",
#                            breaks=c("North", "South"),
#                            labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
#   scale_shape_discrete(name  ="Subtransect",
#                            breaks=c("North", "South"),
#                            labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
#   scale_color_discrete(name  ="Year",
#                            breaks=c("2018", "2019"),
#                            labels=c("2018", "2019")) 


## PLOTS ------
library(ggpubr)
Q2_regressions_citydist <- ggarrange(Q2_reg_ped_subtr,Q2_reg_poll_subtr, Q2_reg_pod_subtr,  Q2_reg_follperinfl_subtr +
                            font("x.text"),
                            ncol = 4,
                            nrow = 1,
                            align = "hv",
                            labels = list("A", "B", "C", "D"),
                            font.label = (size =16),
                            common.legend = T,
                            legend = "top") %T>%
  plot

Q2_regressions_urbscore <- ggarrange(Q2_reg_ped_subtr_u,Q2_reg_poll_subtr_u, Q2_reg_pod_subtr_u,  Q2_reg_follperinfl_subtr_u +
                            font("x.text"),
                            ncol = 4,
                            nrow = 1,
                            align = "hv",
                            labels = list("E", "F", "G", "H"),
                            font.label = (size =16),
                            common.legend = F) %T>%
  plot

city_plots_subtr <- annotate_figure(Q2_regressions_citydist, bottom = text_grob("Distance to Urban Center (km)", size=14))
urbscore_plots_subtr <- annotate_figure(Q2_regressions_urbscore, bottom = text_grob("Urbanization Score", size=14))

city_plots_subtr/urbscore_plots_subtr

dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/Q2_UrbanSubtransects/Subtransect_regressions.pdf", width = 12, height = 8)
```


#### Supplement
##### Height, Gradient regressions
```{r}
### CITY_DIST --------
Q1_reg_height <- ggplot(fertile_pops_all_height_18_19_sept, aes(x = City_dist, y = Height_Sept, shape=Year, color = Year)) +
  labs(x = "Distance to Urban Center (km)", 
    y = "Height (cm)") +
  geom_point(aes(color = Year, shape = Year), size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(colour=Year, shape=Year, fill=Year),size=0.75, method = lm, alpha=0.15, se = T) +
  labs(color="Year", size="Year") +
  scale_y_continuous(limits=c(0,200)) +
  labs(linetype="Year", color="Year", shape = "Year") +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_height

### URB_SCORE--------
Q1_reg_height_u <- ggplot(urb_scores_height_all, aes(x = Urb_score, y = Height_Sept, shape=Year)) +
  labs(x = "Urbanization Score", 
    y = "Height (cm)") +
  geom_point(aes(color = Year, shape = Year), size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(colour=Year, shape=Year, fill=Year),size=0.75, method = lm, alpha=0.15, se = T) +
  labs(color="Year", size="Year") +
  scale_y_continuous(limits=c(0,200)) +
  labs(linetype="Year", color="Year", shape = "Year") +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
Q1_reg_height_u


library(ggpubr)
Q1_regressions_supp <- ggarrange(Q1_reg_height, Q1_reg_height_u + font("x.text"), ncol = 2, nrow = 1, align = "h", labels = list("A", "B"), font.label = (size =16), common.legend = TRUE, legend = "right")
Q1_regressions_supp

dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/Supplement/Gradient_regression_height.pdf", width = 8, height = 4)
```

##### Height, Subtransect regressions
```{r}
## CITY_DIST-----
Q2_reg_height <- ggplot(fertile_pops_all_height_18_19_urban_sept,
                        aes(x = City_dist,
                            y = Height_Sept,
                            group=interaction(Year,Transect_ID),
                            color=interaction(Year,Transect_ID),
                            linetype=interaction(Year,Transect_ID),
                            shape=interaction(Year,Transect_ID))) + 
  geom_point(size=2.5)  +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  labs(x = "Distance to City Center (km)",
    y = "Height (cm)",
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    # axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line"))+
  guides(shape = guide_legend(nrow = 2),
         color = guide_legend(nrow = 2),
         linetype = guide_legend(nrow = 2))
Q2_reg_height


## URB_SCORE-----
Q2_reg_height_u <- ggplot(urb_scores_height,
                        aes(x = Urb_score,
                            y = Height_Sept,
                            group=interaction(Year,Transect_ID),
                            color=interaction(Year,Transect_ID),
                            linetype=interaction(Year,Transect_ID),
                            shape=interaction(Year,Transect_ID))) + 
  geom_point(size=2.5)  +
  scale_x_reverse() +
  geom_smooth(method = lm, alpha=0.15, se = F) +
  labs(x = "Urbanization Score",
    y = "Height (cm)",
       color = "Year, Subtransect",
       shape = "Year, Subtransect",
       linetype = "Year, Subtransect") +
  scale_shape_manual(values = c(1,2,16,17),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_color_manual(values = c("#00BFC4", "#00BFC4", "#F8766D", "#F8766D"),
                     labels = c("2018- Urban: Non-Corridor",
                                "2019- Urban: Non-Corridor",
                                "2018- Urban: Corridor",
                                "2019- Urban: Corridor")) +
  scale_linetype_manual(values = c('solid', 'dashed', 'solid', 'dashed'),
                        labels = c("2018- Urban: Non-Corridor",
                                   "2019- Urban: Non-Corridor",
                                   "2018- Urban: Corridor",
                                   "2019- Urban: Corridor")) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    # axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(2, "line") ) +
  guides(shape = guide_legend(nrow = 2),
         color = guide_legend(nrow = 2),
         linetype = guide_legend(nrow = 2))
Q2_reg_height_u

## PLOTS-----
library(ggpubr)
Q2_regressions_supp <- ggarrange(Q2_reg_height, Q2_reg_height_u + font("x.text"), ncol = 2, nrow = 1, align = "h", labels = list("A", "B"), font.label = (size =16), common.legend = TRUE, legend = "bottom")
Q2_regressions_supp

dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/Supplement/Subtransect_regression_height.pdf", width = 7, height = 4)
```

## Question 3 (Pollinator data)
### Import data
```{r}
#@ Import Pollinator data-----
pollinators <- read.csv(here("./raw_data/Pollinator_PivotTable_byPop_Coded.csv"),  header=T, na.strings=c("","NA"))

# Neaten first column's name
colnames(pollinators)[1] <- "Patch_ID"

# Delete last, empty column
pollinators <- pollinators[-59,]


### Add City_dist values with Haversine formula
# Ref lat and longs are for Yonge & Dundas intersection in downtown Toronto
pollinators$Ref_Lat <- "43.656327"
pollinators$Ref_Long <- "-79.380904"

# Make lat/long cols numeric
pollinators$Lat <- as.numeric(as.character(pollinators$Lat))
pollinators$Long <- as.numeric(as.character(pollinators$Long))
pollinators$Ref_Lat <- as.numeric(as.character(pollinators$Ref_Lat))
pollinators$Ref_Long <- as.numeric(as.character(pollinators$Ref_Long))

# Find distances from Yonge/Dundas to sample sites (in meters)
pollinators <- pollinators %>% mutate(CTD_m = distHaversine(cbind(Long, Lat), cbind(Ref_Long, Ref_Lat)))

# conver to km
pollinators$Dist_city <- pollinators$CTD / 1000

# drop ref lat, long, and city_dist (in m) cols
pollinators <- pollinators[,-c(50:52)]


## Import taxonomy table-----
tax <- read.csv(here("./raw_data/Taxonomy_transposed.csv"),  header=T, na.strings=c("","NA"), fileEncoding = 'UTF-8-BOM')


```

### Manipulate pollinator, taxonomy tables
##### All data
```{r}
# Create new table with average pollinator sightings per plant
poll_pp <- pollinators %>%
  as_tibble %>%
  mutate_at(vars(starts_with("MS_")), funs(./pollinators$Plants_surveyed)) %>%
  # Drop inaccurate Total column
  dplyr::select(., -49) %>%
  # add new accurate total col
  rowwise() %>% 
  mutate(., Total = sum(c_across(MS_01:MS_42)))
  

# Create new table recoding all sightings to binary (0 = not seen; 1 = seen)
poll_binary <- pollinators[,-49] %>%
  mutate_at(vars(starts_with("MS_")), funs(ifelse(. >0, 1, .))) %>%
  # add new accurate total col
  rowwise() %>% 
  mutate(., Total = sum(c_across(MS_01:MS_42)))


# reshape to create diversity table (combining occurrence data with taxonomy)
melted <- melt(pollinators, id=c("Patch_ID", "Lat", "Long", "Dist_city", "Transect", "Plants_surveyed")) %>%
  # remove rows with no pollinators observed, remove "Total"
  filter(value != 0) %>%
  filter(variable != "Total") %>%
  dplyr::rename(Morphospecies_Code = variable, Count = value)

diversity <- merge(x=melted,y=tax,by="Morphospecies_Code",all.x=TRUE)


 ##################  CALCULATING SPECIES DIVERSITY ##################  
pollinators1 <- pollinators[,c(1,7:48)] %>%
  rowwise() %>% 
  add_column(., shannon = vegan::diversity(pollinators1[-1], index="shannon")) %>%
  add_column(., simpson = vegan::diversity(pollinators1[-1], index="simpson")) %>%
  # remove observations per site to just get site and shannon & simpson indices
  dplyr::select(., c(1,44,45))


# Find number of each taxon level present per population
div_sum <- diversity %>%
  group_by(Patch_ID, Dist_city, Transect) %>%
  dplyr::summarise(
    orders = n_distinct(Order),
    superfams = n_distinct(Superfamily),
    families = n_distinct(Family),
    subfams = n_distinct(Subfamily),
    genera = n_distinct(Genus),
    mspecies = n_distinct(Morphospecies_Code)) %>%
  # Find total number of individuals seen per population & add 
  dplyr::full_join(., diversity %>%
                     group_by(Patch_ID) %>%
                     dplyr::summarise(
                       total_indivs = sum(Count)), by = "Patch_ID") %>%
  # add species richness cols
  ## The mspecies column of div_sum is a simple measure of species richness.
  ## Another measure of species richness, or D (Menhinick's index), = the number of species divided by the square root of the number of individuals in the sample.
  # rowwise() %>% 
  mutate(., Menhinicks_index = mspecies / total_indivs^0.5) %>%

## join all the rows from pollinators1 to div_sum, which doesn't have all sites represented (because those missing sites had no pollinators observed). In this case, those sites had a shannon index of 0 and a simpson's index of 1.
 dplyr::left_join(., pollinators1, by = "Patch_ID")



# get max values in shannon's and simpson's diversity columns
max_shannon <- summarise(div_sum, max(shannon))
max_simpson <- summarise(div_sum, max(simpson))

# add simpson's, shannon's equitabilities to div_sum
div_sum <- div_sum %>%
  rowwise() %>%
 # add Shannon's equitability
  dplyr::mutate(., shannon_equit = shannon / max_shannon) %>%
 # add Simpson's equitability
  dplyr::mutate(., simpson_equit = simpson / max_simpson)



 # Find number of each taxon level present per transect
div_transects <- diversity %>%
  group_by(Transect) %>%
  dplyr::summarise(
    Orders = n_distinct(Order),
    Superfamilies = n_distinct(Superfamily),
    Families = n_distinct(Family),
    Subfamilies = n_distinct(Subfamily),
    Genera = n_distinct(Genus),
    Morphospecies = n_distinct(Morphospecies_Code),
    Total_individuals = n())

```
 
##### Without honeybee data
```{r}
# remove honeybee data
diversity_no_honey <- diversity %>% filter(Morphospecies != "Apis mellifera (Large)")

# - - - - -

# Find number of each taxon level present per population
div_sum_no_honey <- diversity_no_honey %>%
  group_by(Patch_ID, Dist_city, Transect) %>%
  dplyr::summarise(
    orders = n_distinct(Order),
    superfams = n_distinct(Superfamily),
    families = n_distinct(Family),
    subfams = n_distinct(Subfamily),
    genera = n_distinct(Genus),
    mspecies = n_distinct(Morphospecies_Code)) %>%
  # Find total number of individuals seen per population & add 
  dplyr::full_join(., diversity_no_honey %>%
                     group_by(Patch_ID) %>%
                     dplyr::summarise(
                       total_indivs = sum(Count)), by = "Patch_ID") %>%
  # add species richness cols
  ## The mspecies column of div_sum is a simple measure of species richness.
  ## Another measure of species richness, or D (Menhinick's index), = the number of species divided by the square root of the number of individuals in the sample.
  # rowwise() %>% 
  mutate(., Menhinicks_index = mspecies / total_indivs^0.5) %>%

## join all the rows from pollinators1 to div_sum, which doesn't have all sites represented (because those missing sites had no pollinators observed). In this case, those sites had a shannon index of 0 and a simpson's index of 1.
 dplyr::left_join(., pollinators1, by = "Patch_ID")



# get max values in shannon's and simpson's diversity columns
max_shannon_no_honey <- summarise(div_sum_no_honey, max(shannon))
max_simpson_no_honey <- summarise(div_sum_no_honey, max(simpson))

# add simpson's, shannon's equitabilities to div_sum
div_sum_no_honey <- div_sum_no_honey %>%
 # add Shannon's equitability
  dplyr::mutate(., shannon_equit = shannon / max_shannon_no_honey) %>%
 # add Simpson's equitability
  dplyr::mutate(., simpson_equit = simpson / max_simpson_no_honey)



 # Find number of each taxon level present per transect
div_transects_no_honey <- diversity_no_honey %>%
  group_by(Transect) %>%
  dplyr::summarise(
    Orders = n_distinct(Order),
    Superfamilies = n_distinct(Superfamily),
    Families = n_distinct(Family),
    Subfamilies = n_distinct(Subfamily),
    Genera = n_distinct(Genus),
    Morphospecies = n_distinct(Morphospecies_Code),
    Total_individuals = n())

```


### Tables
```{r}
# Total pollinators observed per morphospecies:
ms_table <- colSums(pollinators[,c(7:48)]) %>%
  as.data.frame() %>%
  dplyr::rename(indivs_observed = 1)
# top 4 abundant morphospecies: MW 6, 14, 2, 10.
#   6: Apis mellifera (Large)
#   14: (small) black sweat bee (Halictidae spp.)
#   2: orange beetle (Rhagoycha fulva)
#   10: small black sweat bee (yellow face) (Hylaeus spp.)



####### Table of each family's most common morphospecies vs dist city ctr ------
four_popfams <- dplyr::filter(diversity, Family %in% c( 'Apidae', 'Cantharidae' , 'Halictidae', 'Megachilidae')) %>%
  group_by(Morphospecies, Family) %>%
  summarise(
    "Sites" = n_distinct(Patch_ID),
    "Individuals_observed" = sum(Count))

# switch order of first 2 cols
four_popfams <- four_popfams[,c(2,1,3,4)]

# break into 4 separate tables, calculate subtotals, then bind together
apidae <- dplyr::filter(four_popfams, Family %in% 'Apidae') %>% adorn_totals("row")
canth <- dplyr::filter(four_popfams, Family %in% 'Cantharidae')%>% adorn_totals("row")
halict <- dplyr::filter(four_popfams, Family %in% 'Halictidae')%>% adorn_totals("row")
megachil <- dplyr::filter(four_popfams, Family %in% 'Megachilidae')%>% adorn_totals("row")

b <- bind_rows(list(apidae, canth, halict, megachil)) %>%
              arrange(Family, Morphospecies, Sites, Individuals_observed)

d <- rbindlist(list(
  four_popfams %>%
    group_by(Family) %>%
    summarise(sum(Sites), sum(Individuals_observed)),
  four_popfams %>%
    group_by(Family, Morphospecies) %>%
    summarise(sum(Sites), sum(Individuals_observed))),fill=TRUE) %>%
  arrange(Family, Morphospecies)

# Make Total rows clear
d$Family <- as.character(d$Family)
d[8,1] <- as.character("Apidae: Total")
d[10,1] <- as.character("Cantharidae: Total")
d[18,1] <- as.character("Halictidae: Total")
d[29,1] <- as.character("Megachilidae: Total")

colnames(d)[2] <- "Sites Observed"
colnames(d)[3] <- "Individuals Observed"
colnames(d)[4] <- "Morphospecies Description "

kable(d, digits = 3, format = "pandoc", caption = "Top 4 Families") # the digits argument controls rounding
d_export <- kable(d, digits = 3, format = "pandoc", caption = "Top 4 Families")
kable(d, "html") %>%
  kable_styling("striped") %>%
  save_kable(file = "table_d.html", self_contained = T)
  as_image(width = 4)
```

### Graphs
#### Abundance
##### Abundance along gradient & subtransects
```{r}
# Total abundance

## try to get standard error to create confidence intervals here? 
# library(Rmisc)
# sum1 <- summarySE(diversity, measurevar="Count", groupvars= c("Order", "Transect"), na.rm = T)
# sum_a <- summarySE(diversity, measurevars = c("Morphospecies_Code", "Count"), groupvar= ("Patch_ID"), na.rm = T)
# ggplot(sum1, aes(x=Transect, y=Count, color = Order, shape=Order)) +
#   geom_pointrange(aes(ymin=Count-se, ymax=Count+se), size = 1, position = position_jitterdodge(dodge.width = .5)) +
#   geom_smooth(method=lm, se=F, fullrange = T, size = 0.5) +
#   # scale_color_manual(values=c("gray64", "black", 'grey')) +
#   theme_bw() +
#   labs(title = "Total Pollinator Order Abundance by Transect",
#        caption = "Error bars represent standard error")


abun <- ggplot(pollinators, aes(x = Dist_city, y = Total)) +
  labs(x = "Distance to urban center (km)", y = "Average Pollinators Observed") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(color="black", method = lm, alpha=0.15,  se = T) +
  labs(title = 'Pollinator Abundance Along Urban-Rural Gradient') +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    )+
  theme_bw()

# Total abundance, split by transect
abun_transect <- ggplot(pollinators, aes(x = Dist_city, y = Total, shape=Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Average Pollinators Observed") +
  geom_point(aes(shape=Transect, color=Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(color=Transect, linetype = Transect, fill = Transect), method = lm, alpha=0.15,  se = T) +
  labs(title = 'Pollinator Abundance Among Sub-transects', linetype="Transect", color="Transect", linetype = "Transect") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()



# Average abundance per plant
abun_perplant <- ggplot(poll_pp, aes(x = Dist_city, y = Total)) +
  labs(x = "Distance to urban center (km)", y = "Average Pollinators Observed (per plant)") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(color="black", method = lm, alpha=0.15,  se = T) +
  labs(title = 'Pollinator Abundance Along Urban-Rural Gradient', subtitle = "per plant") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()

# Average abundance per plant, split by transect
abun_perplant_transect <- ggplot(poll_pp, aes(x = Dist_city, y = Total, shape=Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Average Pollinators Observed (per plant)") +
  geom_point(aes(shape=Transect, color=Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(color=Transect, linetype = Transect, fill = Transect), method = lm, alpha=0.15,  se = T) +
    labs(title = 'Pollinator Abundance Among Sub-transects', subtitle = "per plant", linetype="Transect", color="Transect", linetype = "Transect") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()



library(cowplot)

# plot_grid(
#   plot_grid(
#     abun + theme(legend.position = "none")
#     , abun_transect + theme(legend.position = "none")
#     , abun_perplant+ theme(legend.position = "none")
#     , abun_perplant_transect + theme(legend.position = "none")
#     , ncol = 2
#     , align = "hv")
#   , plot_grid(
#     get_legend(abun_transect)
#     , ggplot()
#     , ncol =1)
#   , rel_widths = c(8,1)
#   )

```

##### Abundance of 4 most populous families
```{r}
#### wrapped regressions per family vs dist city ctr ####
ggplot(subset(diversity, Family %in% c('Apidae', 'Cantharidae', 'Halictidae', 'Megachilidae')), aes(x = Dist_city, y = Count, colour = Family)) +
  labs(x = "Distance to urban center (km)", y = "Individuals Observed by Family (per population)") +
  geom_point(aes( color = Family)) +
  scale_shape(solid = F)+
  geom_smooth(aes(color = Family), method = lm, alpha=0.15,  se = T) +
  labs() +
  facet_wrap(~Family) +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()


####### regressions of each family's most common morphospecies vs dist city ctr #######
top_4ms <- dplyr::filter(diversity, Morphospecies_Code %in% c( 'MS_06', 'MS_14' , 'MS_02', 'MS_21')) 
ggplot(top_4ms, aes(x = Dist_city, y = Count, colour = Morphospecies)) +
  labs(x = "Distance to urban center (km)", y = "Individuals Observed") +
  geom_point(aes( color = Morphospecies)) +
  scale_shape(solid = F)+
  geom_smooth(aes(color = Morphospecies), method = lm, alpha=0.15,  se = T) +
  facet_grid(~Family + Morphospecies,
             labeller = label_context) +
  theme(legend.position = "none") 
  
  
  
###### Bombus abundance re: dist city ctr #######
  ggplot(subset(diversity, Genus %in% 'Bombus'), aes(x = Dist_city, y = Count)) +
  labs(x = "Distance to urban center (km)", y = "Bombus Individuals Observed (per population)") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth( method = lm, alpha=0.15,  se = T) +
  labs()
  
# Only 3 data points, so not very interesting/reliable.
  

###### Monarch abundance re: dist city ctr #######
  ggplot(subset(diversity, Genus %in% 'Danaus'), aes(x = Dist_city, y = Count)) +
  labs(x = "Distance to urban center (km)", y = "Monarchs Observed (per population)") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth( method = lm, alpha=0.15,  se = T) +
  labs()
  
# Only 4 data points, so not very interesting/reliable.
  
  
###### Honeybee abundance re: dist city ctr #######
  ggplot(subset(diversity, Morphospecies %in% 'Apis mellifera (Large)'), aes(x = Dist_city, y = Count)) +
  labs(x = "Distance to urban center (km)", y = "Honeybees Observed (per population)") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth( method = lm, alpha=0.15,  se = T) +
  labs()
  
```

#### Diversity
##### Total diversity
```{r}
# Total morphospecies diversity
ggplot(poll_binary, aes(x = Dist_city, y = Total)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(color="black", method = lm, alpha=0.15,  se = T) +
  labs(title = 'Pollinator Morphospecies Present Along Urban-Rural Gradient') +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()

 
 
div_sum_melted <- reshape2::melt(div_sum, id.vars= c("Patch_ID", "Transect", "Dist_city"), measure.vars = c('orders', 'superfams', 'families', 'subfams', 'genera', 'mspecies', 'total_indivs', 'Menhinicks_index', 'shannon', 'simpson', 'shannon_equit', 'simpson_equit'))

######################## BY TRANSECT ############################


# Total morphospecies diversity, split by transect
ggplot(poll_binary, aes(x = Dist_city, y = Total, shape=Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed (per population)") +
  geom_point(aes(shape=Transect, color=Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(color=Transect, linetype = Transect), method = lm, alpha=0.15,  se = T) +
  labs(linetype="Transect", color="Transect", linetype = "Transect") +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    )  +
  theme_bw()



# Orders per transect
ord_trsct <- ggplot(div_sum, aes(x = Dist_city, y = orders, shape = Transect, colour = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Orders") +
  geom_point(aes(shape = Transect, color = Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Transect, color = Transect), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()



# Superfamilies per transect
supfam_trsct <- ggplot(div_sum, aes(x = Dist_city, y = superfams, shape = Transect, colour = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Superfamilies") +
  geom_point(aes(shape = Transect, color = Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Transect, color = Transect), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()

# Morphospecies per transect
mspecies_trsct <- ggplot(div_sum, aes(x = Dist_city, y = mspecies, shape = Transect, colour = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies") +
  geom_point(aes(shape = Transect, color = Transect)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Transect, color = Transect), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) +
  theme_bw()

# 
# plot_grid(
#   plot_grid(
#     ord_trsct + theme(legend.position = "none")
#     , supfam_trsct + theme(legend.position = "none")
#     , fams_trsct+ theme(legend.position = "none")
#     , subfams_trsct + theme(legend.position = "none")
#     , mspecies_trsct+ theme(legend.position = "none")
#     , ncol = 2
#     , align = "hv")
#   , plot_grid(
#     get_legend(ord_trsct)
#     , ggplot()
#     , ncol =1)
#   , rel_widths = c(8,1)
#   )
# 

```

##### Diversity, Richness, and Evenness indices
###### Diversity
```{r}
# Major gradient, with cleaned up labels
ggplot(subset(div_sum_melted, variable %in% c( 'shannon', 'simpson')), aes(x = Dist_city, y = value, shape = variable, color = variable)) +
    scale_shape_discrete(name  ="Diversity Index",
                           labels=c("Shannon", "Simpson")) +
    scale_colour_discrete(name  ="Diversity Index",
                            labels=c("Shannon", "Simpson")) +
  scale_linetype_discrete(name  ="Diversity Index",
                            labels=c("Shannon", "Simpson")) +
  labs(x = "Distance to urban center (km)", y = "Diversity") +
  geom_point() +
  geom_smooth(aes(linetype = variable), method = lm, alpha=0.15,  se = T) +
  labs(title = "Shannon's and Simpson's Diversity Indices") +
  theme_bw()

# Major gradient, with cleaned up labels, JUST Simpson
ggplot(div_sum_melted, aes(x = Dist_city, y = value)) +
  labs(x = "Distance to urban center (km)", y = "Diversity Index") +
  geom_point(data=div_sum_melted[div_sum_melted$variable== 'simpson', ]) +
  geom_smooth(data=div_sum_melted[div_sum_melted$variable== 'simpson', ], color = "black", method = lm, alpha=0.15,  se = T) +
  labs(title = "Simpson's Diversity Index") +
  theme_bw()


var.labs <- c("Shannon's Diversity", "Simpson's Diversity")
names(var.labs) <- c("shannon", "simpson")

# Split into transects
div_fig2 <- ggplot(subset(div_sum_melted, variable %in% c( 'shannon', 'simpson')), aes(x = Dist_city, y = value, shape = Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Diversity") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(aes(fill = Transect), method = lm, alpha=0.15,  se = T) +
  labs(title = "Shannon's and Simpson's Diversity Indices by Transect") +
  facet_grid(~variable, labeller = labeller(variable = var.labs))

## Just Simpson's
ggplot(div_sum_melted, aes(x = Dist_city, y = value, shape = Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Diversity Index") +
    scale_shape(solid = F)+
  geom_point(data=div_sum_melted[div_sum_melted$variable== 'simpson', ]) +
  geom_smooth(data=div_sum_melted[div_sum_melted$variable== 'simpson', ], aes(fill = Transect), method = lm, alpha=0.15,  se = T) +
  labs(title = "Simpson's Diversity Index by Transect")


```


###### Richness
```{r}
# Major gradient
rich_fig1 <- ggplot(subset(div_sum_melted, variable %in% c('Menhinicks_index')), aes(x = Dist_city, y = value), shape = 1, color = "black") +
  labs(x = "Distance to urban center (km)", y = "Species Richness") +
  geom_point(show.legend = FALSE) +
  scale_shape(solid = F)+
  geom_smooth(color = "black", method = lm, alpha=0.15,  se = T, show.legend = FALSE) +
  labs(title = "Menhinick's Species Richness") 


# Split into transects
rich_fig2 <- ggplot(subset(div_sum_melted, variable %in% c('Menhinicks_index')), aes(x = Dist_city, y = value, shape = Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Species Richness") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(aes( fill = Transect), method = lm, alpha=0.15,  se = T) +
  labs(title = "Menhinick's Species Richness by Transect") 

```

###### Evenness
```{r}
# Major gradient
even_fig1 <- ggplot(subset(div_sum_melted, variable %in% c( 'shannon_equit', 'simpson_equit')), aes(x = Dist_city, y = value, shape = variable, color = variable)) +
  labs(x = "Distance to urban center (km)", y = "Equitability") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth( method = lm, alpha=0.15,  se = T) +
  labs(title = "Shannon's and Simpson's Equitabilities")


# Split into transects
even_fig2 <- ggplot(subset(div_sum_melted, variable %in% c( 'shannon_equit', 'simpson_equit')), aes(x = Dist_city, y = value, shape = Transect, color = Transect)) +
  labs(x = "Distance to urban center (km)", y = "Equitability") +
  geom_point() +
  scale_shape(solid = F)+
  geom_smooth(aes(fill = Transect), method = lm, alpha=0.15,  se = T) +
  labs(title = "Shannon's and Simpson's Equitabilities by Transect") +
  facet_grid(~variable)



```

###### Plot all
```{r}

library(cowplot)

# Total
plot_grid(
  plot_grid(
    div_fig1 + theme(legend.position = "none")
    , even_fig1 + theme(legend.position = "none")
    , rich_fig1 
    , ncol = 1
    , align = "hv")
  , plot_grid(
    get_legend(div_fig1)
    , ggplot()
    , ncol =1)
  , rel_widths = c(7,3)
  )

# By transect
plot_grid(
  plot_grid(
    div_fig2 + theme(legend.position = "none")
    , even_fig2 + theme(legend.position = "none")
    , rich_fig2 + theme(legend.position = "none")
    , ncol = 1
    , align = "h")
  , plot_grid(
    get_legend(even_fig2)
    , ggplot()
    , ncol =1)
  , rel_widths = c(9,1)
  )
```


##### Diversity: by Order
```{r}
# ORDER
ggplot(data=diversity, aes(x=Dist_city, group=Order, fill=Order)) +
    geom_density(adjust=1.5, alpha=.4) 

ggplot(data=diversity, aes(x=Dist_city, group=Order, fill=Order)) +
    geom_density(adjust=1.5) +
    facet_wrap(~Order) +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      axis.ticks.x=element_blank())

ggplot(data=diversity, aes(x=Dist_city, group=Order, fill=Order)) +
    geom_density(adjust=1.5, alpha=.4) +
    facet_wrap(~Transect) +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      axis.ticks.x=element_blank())

#install.packages('ggridges')
library(ggridges)
library(ggplot2)
ggplot(diversity, aes(x = Dist_city, y = Order, fill = Order)) +
  geom_density_ridges(alpha=0.6, stat="binline", bins=30) +
  theme_ridges() + 
  theme(legend.position = "none")

ggplot(diversity, aes(x = Dist_city, y = Order, fill = Order)) +
  geom_density_ridges(alpha=0.6) +
  theme_ridges() + 
  theme(legend.position = "none")

ggplot(diversity, aes(x = Dist_city, y = Count, shape = Order, colour = Order)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed (per population)") +
  geom_point(aes(shape = Order, color = Order)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Order, color = Order), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) 


ggplot(diversity, aes(x = Dist_city, y = Count, shape = Order, colour = Order)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed (per population)") +
  geom_point(aes(shape = Order, color = Order)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Order, color = Order), method = loess, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    ) 

ggplot(data=diversity, aes(x=Order, y=Count)) +
  geom_bar(aes(fill=Order),stat = "identity")+
  theme_bw()

ggplot(sum1, aes(x=Transect, y=Count, fill=Order)) +
  geom_bar(aes(fill=factor(Order)),stat = "identity", position="dodge") +
  geom_errorbar(aes(ymax = Count + se, ymin = Count - se), position = position_dodge(width = 0.9), width = 0.25) +
  scale_fill_grey(start = 0.8, end = 0.5) +
  theme_bw() +
    labs(title = "Total Pollinator Order Abundance by Transect",
       caption = "Error bars represent standard error")




## using SummarySE
library(Rmisc)
sum1 <- summarySE(diversity, measurevar="Count", groupvars= c("Order", "Transect"), na.rm = T)

ggplot(sum1, aes(x=Transect, y=Count, color = Order, shape=Order)) +
  geom_pointrange(aes(ymin=Count-se, ymax=Count+se), size = 1, position = position_jitterdodge(dodge.width = .5)) +
  geom_smooth(method=lm, se=F, fullrange = T, size = 0.5) +
    scale_color_grey(start = 0.8, end = 0.5) +
  # scale_color_manual(values=c("gray64", "black", 'grey')) +
  theme_bw() +
  labs(title = "Total Pollinator Order Abundance by Transect",
       caption = "Error bars represent standard error")



```

##### Diversity: by Superfamily
```{r}
# SUPERFAMILY
ggplot(data=diversity, aes(x=Dist_city, group=Superfamily, fill=Superfamily)) +
    geom_density(adjust=1.5, alpha=.4) 

ggplot(data=diversity, aes(x=Dist_city, group=Superfamily, fill=Superfamily)) +
    geom_density(adjust=1.5) +
    facet_wrap(~Superfamily) +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      axis.ticks.x=element_blank())

ggplot(diversity, aes(x = Dist_city, y = Count, shape = Superfamily, colour = Superfamily)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed (per population)") +
  geom_point(aes(shape = Superfamily, color = Superfamily)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Superfamily, color = Superfamily), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    )

ggplot(data=diversity, aes(x=Superfamily, y=Count)) +
  geom_bar(aes(fill=Superfamily),stat = "identity")+
  theme_bw()




## using SummarySE
library(Rmisc)
sum2 <- summarySE(diversity, measurevar="Count", groupvars= c("Superfamily", "Transect"), na.rm = T)

ggplot(sum2, aes(x=Transect, y=Count, color = Superfamily, shape=Superfamily)) +
  geom_pointrange(aes(ymin=Count-se, ymax=Count+se), size = 1, position = position_jitterdodge(dodge.width = .5)) +
  geom_smooth(method=lm, se=F, fullrange = T, size = 0.5) +
  # scale_color_manual(values=c("gray64", "black", 'grey')) +
  theme_bw() +
  labs(title = "Total Pollinator Superfamily Abundance by Transect",
       caption = "Error bars represent standard error")



```

##### Diversity: by Family
```{r}
# FAMILY
ggplot(data=diversity, aes(x=Dist_city, group=Family, fill=Family)) +
    geom_density(adjust=1.5, alpha=.4) 

ggplot(data=diversity, aes(x=Dist_city, group=Family, fill=Family)) +
    geom_density(adjust=1.5) +
    facet_wrap(~Family) +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      axis.ticks.x=element_blank()
    )

ggplot(diversity, aes(x = Dist_city, y = Count, shape = Family, colour = Family)) +
  labs(x = "Distance to urban center (km)", y = "Morphospecies Observed (per population)") +
  geom_point(aes(shape = Family, color = Family)) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape = Family, color = Family), method = lm, alpha=0.15,  se = T) +
  labs() +
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=18),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) 
    )


ggplot(data=diversity, aes(x=Family, y=Count)) +
  geom_bar(aes(fill=Family),stat = "identity")+
  theme_bw() +
  labs(title = "Total Individuals Observed per Family")




# Sankey diagram

sank1 <- diversity[,c(6,8,9,11:13)]
sank1[sank1=="Unidentified"]<- "Unknown"
sank1 <- sank1 %>% ddply( .(Transect, Order, Family, Genus), summarise, sum_counts = sum(Count))

# install.packages("wesanderson")
# library(wesanderson)
# install.packages("flipPlots")
# install_github("Displayr/flipPlots")
# install.packages("RColorBrewer")
library("RColorBrewer")
library(flipPlots)
SankeyDiagram(sank1[, -5],
              link.color = "Target",
              variables.share.values = T,
              label.show.varname = F,
              label.show.counts = T,
              weights = sank1$Count,
              font.size = 20,
              colors =  topo.colors(25),
              # colors =  terrain.colors(25),
              # colors =  grey.colors(25),
              sinks.right = F,
              max.categories = 12,
              hovertext.show.percentages = T) 
# it helps to move around the nodes to make them flow more simply


## using SummarySE
library(Rmisc)
sum3 <- summarySE(diversity, measurevar="Count", groupvars= c("Family", "Transect"), na.rm = T)

ggplot(sum3, aes(x=Transect, y=Count, color = Family, shape=Family)) +
  geom_pointrange(aes(ymin=Count-se, ymax=Count+se), size = 1, position = position_jitterdodge(dodge.width = .5)) +
  geom_smooth(method=lm, se=F, fullrange = T, size = 0.5) +
  # scale_color_manual(values=c("gray64", "black", 'grey')) +
  theme_bw() +
  labs(title = "Total Pollinator Family Abundance by Transect",
       caption = "Error bars represent standard error")




```

#### Composite figure
```{r}
# TOTAL ABUNDANCE
abun_all <- ggplot(div_sum, aes(x = Dist_city, y = total_indivs^(1/2))) +
  labs(   # x = "Distance to urban center (km)",
    y = expression(Pollinators~Observed^{0.5})) +
  geom_point(size=2) +
  scale_shape(solid = F)+
  geom_smooth(color = "black", size=0.75, method = lm, alpha=0.15, se = T) +
  # scale_y_continuous(limits=c(0,200)) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
abun_all


# urban transects- abundance
abun_transects <- ggplot(div_sum_urban, aes(x = Dist_city, y = total_indivs, shape=Transect, color = Transect)) + 
  labs(   # x = "Distance to urban center (km)", 
    y = "Pollinators Observed") +
  geom_point(aes(shape=Transect, color=Transect),  size=2) +
  scale_shape(solid = F)+
  geom_smooth(aes(shape=Transect, color=Transect, linetype = Transect, fill = Transect), size=0.75, method = lm, alpha=.15, se = T) +
  # scale_y_continuous(breaks=c(0,1,2,3), limits=c(0,3)) +
  labs(linetype="Transect", color="Transect", shape="Transect") +
  theme(legend.position = "none",
    legend.justification = c("right", "top"),
    legend.box = 'horizontal',
    legend.box.just = "right",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) ) 
abun_transects


# Simpson's Diversity
simp_all <- ggplot(div_sum, aes(x = Dist_city, y = log(1-simpson))) +
  labs(   # x = "Distance to urban center (km)", 
    y = "log(1-Simpson's Index)") +
  geom_point(size=2) +
  scale_shape(solid = F)+
  geom_smooth(color = "black", size=0.75, method = lm, alpha=0.15, se = T) +
  # scale_y_continuous(limits=c(0,200)) +
  theme(legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.box = 'horizontal',
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) )
simp_all


# Simpson's Diversity- urban subtransects
simp_transects <- ggplot(div_sum_urban, aes(x = Dist_city, y = log(1-simpson), shape=Transect, color = Transect)) + 
  labs(   # x = "Distance to urban center (km)", 
    y = "log(1-Simpson's Index)") +
  geom_point(aes(shape=Transect, color=Transect),  size=2) +
  # scale_shape(solid = F)+
  geom_smooth(aes(color=Transect, linetype = Transect, fill = Transect), size=0.75, method = lm, alpha=.15, se = T) +
  # scale_y_continuous(breaks=c(0,1,2,3), limits=c(0,3)) +
  # labs(linetype="Transect", color="Transect", shape="Transect") +
  theme(legend.position = "bottom",
    legend.justification = c("center", "top"),
    legend.box = 'horizontal',
    legend.box.just = "center",
    legend.margin = margin(5,5,5,5),
    text = element_text(size=14),
    legend.text=element_text(size=14),
    axis.title.x = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.key = element_rect(fill = NA) ) +
   scale_color_manual(values = c('#F8766D', '#00BFC4'),
                     breaks = c("North", "South"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor"),
                       name = "Subtransect") +
   scale_shape_manual(values = c(1,2),
                      breaks = c("North", "South"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor"),
                       name = "Subtransect") +
   scale_linetype_manual(values = c("solid", "dashed"),
                      breaks = c("North", "South"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor"),
                       name = "Subtransect") +
   scale_fill_manual(values = c('#F8766D', '#00BFC4'),
                      breaks = c("North", "South"),
                       labels = c("Urban: Non-Corridor", "Urban: Corridor"),
                       name = "Subtransect")
  
simp_transects


library(ggpubr)
Q2_regressions <- ggarrange(abun_all,  abun_transects, simp_all, simp_transects, ncol = 2, nrow = 2, align = "v", labels = list("A", "B", "C", "D"), font.label = (size =16), common.legend = FALSE)
Q2_regressions

annotate_figure(Q2_regressions, bottom = text_grob("Distance to Urban Center (km)", size=14))

dev.copy2pdf(file="~/R_Projects/Chapter1/Figures_Tables/Pollinator_regressions.pdf", width = 10, height = 7)
```
### Statistical Analysis
#### Linear Models
##### Abundance
####### Without transects- SQUARE ROOT TRANSFORMATION
```{r}

# Linear model 1

lm1 <- lm(total_indivs ~ Dist_city, data = div_sum )

par(mfrow=c(2,2))
plot(lm1)
plot(total_indivs ~ Dist_city, div_sum)
lm1_sum <- summary(lm1)

lm1_sum$coefficients[1,1] # this is the intercept (or, in y=mx + b, it's the b)
lm1_sum$coefficients[2,1] # this is the slope (or, in y=mx + b, it's the m)
lm1_sum$coefficients[2,4] # p-value
lm1_sum$fstatistic[1] # F statistic
lm1_sum$r.squared # R-squared value
nobs(lm1_sum) # number of observations



######### Diagnostics ##########
lm1_df <- div_sum[,c(1:3,10)]
lm1_df$predicted <- predict(lm1)   # Save the predicted values
lm1_df$residuals <- residuals(lm1) # Save the residual values

ggplot(lm1_df, aes(x = Dist_city, y = total_indivs)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +
  geom_segment(aes(xend = Dist_city, yend = predicted), alpha = .2) +
  geom_point(aes(color = abs(residuals), size = abs(residuals))) + # size also mapped
  scale_color_continuous(low = "black", high = "red") +
  guides(color = FALSE, size = FALSE) +  # Size legend also removed
  geom_point(aes(y = predicted), shape = 1) +
  theme_bw()

# residuals vs predicted values look ok... some potential outliers

## Histogram
gg_reshist(lm1, bins=20)


diagnostic<-function(x){
  plot(x)
  abline(mean(x),0)
  hist(x)
  qqnorm(x)
  qqline(x,lty=2, col="Red")
  skewness(x)
  kurtosis(x)
  print(paste("Kurtosis=", kurtosis(x), sep=""))
  print(paste("Skew=", skewness(x), sep=""))}

diagnostic(lm1$residuals)
# right-skewed

# get t-value
lm1_tval <- skewness(lm1_df$residuals)/sqrt(6/length(lm1_df$residuals))

# What's the chance of getting a t-value of 0.304 by chance alone, when the skew value really is zero?
1-pt(lm1_tval,length(lm1_df$residuals))

# 0.001 is way less than 0.05, so it looks like the data is NOT normal.
# Conclusion: look into transformation or alternative models. Try square root transformation first.

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Option 1: square root transformation

lm1_df$sqrt <- sqrt(lm1_df$total_indivs)

lm1_sqrt <- lm(sqrt ~ Dist_city, data = lm1_df)

lm1_df$predicted_sqrt <- predict(lm1_sqrt)   # Save the predicted values
lm1_df$residuals_sqrt <- residuals(lm1_sqrt) # Save the residual values

ggplot(lm1_df, aes(x = Dist_city, y = sqrt)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +
  geom_segment(aes(xend = Dist_city, yend = predicted_sqrt), alpha = .2) +
  geom_point(aes(color = abs(residuals_sqrt), size = abs(residuals_sqrt))) + # size also mapped
  scale_color_continuous(low = "black", high = "red") +
  guides(color = FALSE, size = FALSE) +  # Size legend also removed
  geom_point(aes(y = predicted_sqrt), shape = 1) +
  theme_bw()

# residuals vs predicted values look more balanced than first diagnostics

diagnostic(lm1_df$residuals_sqrt)
plot(lm1_sqrt)

# get t-value
lm1_sqrt_tval <- skewness(lm1_df$residuals_sqrt)/sqrt(6/length(lm1_df$residuals_sqrt))

# What's the chance of getting a t-value of -1.097 by chance alone, when the skew value really is zero?
1-pt(lm1_sqrt_tval,length(lm1_df$residuals_sqrt))

# 0.1 is higher than 0.05 and it looks a lot better now.
# Conclusion: Stick with the square root transformation.

# Linear model 2: sq rt

par(mfrow=c(2,2))
plot(lm1_sqrt)
lm1_sqrt_sum <- summary(lm1_sqrt)

lm1_sqrt_sum$coefficients[1,1] # this is the intercept (or, in y=mx + b, it's the b)
lm1_sqrt_sum$coefficients[2,1] # this is the slope (or, in y=mx + b, it's the m)
lm1_sqrt_sum$coefficients[2,4] # p-value
lm1_sqrt_sum$fstatistic[1] # F statistic
lm1_sqrt_sum$r.squared # R-squared value
nobs(lm1_sqrt_sum) # number of observations
gg_reshist(lm1_sqrt, bins=20)

```


####### With transects- NO TRANSFORMATION
```{r}

# ## USE URBAN SUBSET
div_sum_urban <- div_sum %>% filter(Transect != 'Rural')


lm1 <- lm(total_indivs ~ Dist_city * Transect, data = div_sum_urban )

par(mfrow=c(2,2))
plot(lm1)
plot(total_indivs ~ Dist_city, div_sum_urban)
lm1_sum <- summary(lm1)

## Histogram
gg_reshist(lm1, bins=20)


diagnostic<-function(x){
  plot(x)
  abline(mean(x),0)
  hist(x)
  qqnorm(x)
  qqline(x,lty=2, col="Red")
  skewness(x)
  kurtosis(x)
  print(paste("Kurtosis=", kurtosis(x), sep=""))
  print(paste("Skew=", skewness(x), sep=""))}

diagnostic(lm1$residuals)
# right-skewed

# I think it looks normal enough, especially because it's not a huge sample size (n = 31 pops)
```


##### Diversity
###### Shannon Diversity
####### Without transects- NO TRANSFORMATION NEEDED
```{r}

# Linear model 2: Shannon's Diversity Index

lm2 <- lm(shannon ~ Dist_city, data = div_sum )

par(mfrow=c(2,2))
plot(lm2)
lm2_sum <- summary(lm2)

# lm2_sum$coefficients[1,1] # this is the intercept (or, in y=mx + b, it's the b)
# lm2_sum$coefficients[2,1] # this is the slope (or, in y=mx + b, it's the m)
# lm2_sum$coefficients[2,4] # p-value
# lm2_sum$fstatistic[1] # F statistic
# lm2_sum$r.squared # R-squared value
# nobs(lm2_sum) # number of observations
# 
# 
# 
# ######### Diagnostics ##########
# lm2_df <- div_sum[,c(1:3,12)]
# lm2_df$predicted <- predict(lm2)   # Save the predicted values
# lm2_df$residuals <- residuals(lm2) # Save the residual values
# 
# ggplot(lm2_df, aes(x = Dist_city, y = shannon)) +
#   geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +
#   geom_segment(aes(xend = Dist_city, yend = predicted), alpha = .2) +
#   geom_point(aes(color = abs(residuals), size = abs(residuals))) + # size also mapped
#   scale_color_continuous(low = "black", high = "red") +
#   guides(color = FALSE, size = FALSE) +  # Size legend also removed
#   geom_point(aes(y = predicted), shape = 1) +
#   theme_bw()

# residuals vs predicted values look ok... somewhat balanced

## Histogram
gg_reshist(lm2, bins=20)
# gg_reshist(lm(shannon^(1/2) ~ Dist_city, data = div_sum ), bins=20 ) + labs(title = "Histogram of Sqrt(residuals)")
# gg_reshist(lm(log(shannon + 1) ~ Dist_city, data = div_sum ), bins=20)+ labs(title = "Histogram of log(residuals)")

diagnostic(lm2$residuals)
# very high kurtosis

# get t-value
lm2_tval <- skewness(lm2_df$residuals)/sqrt(6/length(lm2_df$residuals))

# What's the chance of getting a t-value of -0.1801351 by chance alone, when the skew value really is zero?
1-pt(lm2_tval,length(lm2_df$residuals))

# 0.57 is way higher than 0.05, so it looks like the data is somewhat normal.
# Conclusion: It's fine.


```

####### With transects- SQUARE ROOT TRANSFORMATION
```{r}

lm2 <- lm(shannon ~ Dist_city * Transect, data = div_sum_urban )

par(mfrow=c(2,2))
plot(lm2)
lm2_sum <- summary(lm2)

## Histogram
gg_reshist(lm2, bins=20)

diagnostic(lm2$residuals)
# seems fine

# May be left-skewed... try a transformation
par(mfrow=c(2,2))
plot(lm(shannon^(2) ~ Dist_city * Transect, data = div_sum_urban ))
# Looks much better!


# Conclusion: Go with squaring transformation.


```

###### Simpson Diversity
####### Without transects- log(1-x) TRANSFORMATION
```{r}

# Linear model 3: Simpson's Diversity Index

lm3 <- lm(simpson.y ~ Dist_city, data = div_sum )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# some left skew

# get t-value
lm3_tval <- skewness(lm3_df$residuals)/sqrt(6/length(lm3_df$residuals))
lm3_tval

# What's the chance of getting a t-value of -3.312497 by chance alone, when the skew value really is zero?
1-pt(lm3_tval,length(lm3_df$residuals))

# 0.999 is way higher than 0.05, but the data doesn't look normal.

# Conclusion: Try a transformation: 
gg_reshist(lm(simpson.y ~ Dist_city, data = div_sum ), bins=30 ) 
gg_reshist(lm(simpson.y^(3) ~ Dist_city, data = div_sum ), bins=10 )
gg_reshist(lm(log(1-simpson.y) ~ Dist_city, data = div_sum ), bins=10) # going to try this first.


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Option 1: log(1-simpson) transformation

lm3_df$log_inv <- log(1-lm3_df$simpson)

lm3_log_inv <- lm(log_inv ~ Dist_city, data = lm3_df)

lm3_df$predicted_log_inv <- predict(lm3_log_inv)   # Save the predicted values
lm3_df$residuals_log_inv <- residuals(lm3_log_inv) # Save the residual values

ggplot(lm3_df, aes(x = Dist_city, y = log_inv)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +
  geom_segment(aes(xend = Dist_city, yend = predicted_log_inv), alpha = .2) +
  geom_point(aes(color = abs(residuals_log_inv), size = abs(residuals_log_inv))) + # size also mapped
  scale_color_continuous(low = "black", high = "red") +
  guides(color = FALSE, size = FALSE) +  # Size legend also removed
  geom_point(aes(y = predicted_log_inv), shape = 1) +
  theme_bw()

# residuals vs predicted values look more balanced than first diagnostics

diagnostic(lm3_df$residuals_log_inv)

# get t-value
lm3_log_inv_tval <- skewness(lm3_df$residuals_log_inv)/sqrt(6/length(lm3_df$residuals_log_inv))

# What's the chance of getting a t-value of 1.304685 by chance alone, when the skew value really is zero?
1-pt(lm3_log_inv_tval,length(lm3_df$residuals_log_inv))

# 0.106 is higher than 0.05 and it looks a lot better now.
# Conclusion: Stick with the log(constant - simpson) transformation.

```


####### With transects- log(1-x) TRANSFORMATION
```{r}



# Linear model 3: Simpson's Diversity Index

lm3 <- lm(simpson ~ Dist_city * Transect, data = div_sum_urban )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# extreme left skew!

# Conclusion: Try a transformation: 
gg_reshist(lm(simpson ~ Dist_city* Transect, data = div_sum_urban ), bins=30 ) 
gg_reshist(lm(simpson^(3) ~ Dist_city* Transect, data = div_sum_urban ), bins=10 )
gg_reshist(lm(log(1-simpson) ~ Dist_city* Transect, data = div_sum_urban ), bins=10) # going to try this first.


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Option 1: log(1-simpson) transformation

lm3_df$log_inv <- log(1-lm3_df$simpson)

lm3_log_inv <- lm(log_inv ~ Dist_city, data = lm3_df)

lm3_df$predicted_log_inv <- predict(lm3_log_inv)   # Save the predicted values
lm3_df$residuals_log_inv <- residuals(lm3_log_inv) # Save the residual values

ggplot(lm3_df, aes(x = Dist_city, y = log_inv)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +
  geom_segment(aes(xend = Dist_city, yend = predicted_log_inv), alpha = .2) +
  geom_point(aes(color = abs(residuals_log_inv), size = abs(residuals_log_inv))) + # size also mapped
  scale_color_continuous(low = "black", high = "red") +
  guides(color = FALSE, size = FALSE) +  # Size legend also removed
  geom_point(aes(y = predicted_log_inv), shape = 1) +
  theme_bw()

# residuals vs predicted values look more balanced than first diagnostics

diagnostic(lm3_df$residuals_log_inv)

# Conclusion: Looks much better! Stick with the log(constant - simpson) transformation.

```
###### Simpson Diversity- without honeybees
####### Without transects- SQUARE TRANSFORMATION
```{r}

# Linear model 3: Simpson's Diversity Index

lm3 <- lm(simpson ~ Dist_city, data = div_sum_no_honey )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=10)

diagnostic(lm3$residuals)
# some left skew

# The data doesn't look normal.

# Conclusion: Try a transformation: 
gg_reshist(lm(simpson ~ Dist_city, data = div_sum_no_honey ), bins=10 )
gg_reshist(lm(simpson^(2) ~ Dist_city, data = div_sum_no_honey ), bins=10 )
gg_reshist(lm(simpson^(3) ~ Dist_city, data = div_sum_no_honey ), bins=10 )

par(mfrow=c(2,2))
plot(lm(simpson^(2) ~ Dist_city, data = div_sum_no_honey ))
# Looks MUCH better. With only 48 observations, it's a small dataset too.

# Conclusion: use square transformation.

div_sum_no_honey$simpson_sq <- div_sum_no_honey$simpson^2

```


####### With transects- CUBE TRANSFORMATION
```{r}
# ## USE URBAN SUBSET
div_sum_urban_no_honey <- div_sum_no_honey %>% filter(Transect != 'Rural')


# Linear model 3: Simpson's Diversity Index

lm3 <- lm(simpson ~ Dist_city * Transect, data = div_sum_urban_no_honey )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=10)

diagnostic(lm3$residuals)
# extreme left skew!

# Conclusion: Try a transformation: 
gg_reshist(lm(simpson ~ Dist_city* Transect, data = div_sum_urban_no_honey ), bins=10 )
gg_reshist(lm(simpson^(2) ~ Dist_city* Transect, data = div_sum_urban_no_honey ), bins=10 )
gg_reshist(lm(simpson^(3) ~ Dist_city* Transect, data = div_sum_urban_no_honey ), bins=10 )
# cube transformation looks very good, especially since this is a small dataset again (31 entries)

par(mfrow=c(2,2))
plot(lm(simpson^(3) ~ Dist_city* Transect, data = div_sum_urban_no_honey ))

# Conclusion: Stick with the cube transformation.

div_sum_urban_no_honey$simpson_cube <- div_sum_urban_no_honey$simpson^3

```
###### Species Richness
####### Without transects- NO TRANSFORMATION NEEDED
```{r}
lm3 <- lm(Menhinicks_index ~ Dist_city, data = div_sum )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# Very normal!



# Conclusion: No transformation needed.
```
####### With transects- NO TRANSFORMATION NEEDED
```{r}

lm3 <- lm(Menhinicks_index ~ Dist_city * Transect, data = div_sum_urban )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# SLIGHT left skew

# Conclusion: Try a transformation: 
gg_reshist(lm(Menhinicks_index ~ Dist_city* Transect, data = div_sum_urban ), bins=10 ) 
gg_reshist(lm(Menhinicks_index^(2) ~ Dist_city* Transect, data = div_sum_urban ), bins=10 )

par(mfrow=c(2,2))
plot(lm(Menhinicks_index^2 ~ Dist_city * Transect, data = div_sum_urban ))

# Squaring makes it look a tiny bit better but I think keeping it normal is fine.
```
###### Equitability (Evenness)
####### Without transects- NO TRANSFORMATION NEEDED
```{r}
lm3 <- lm(shannon_equit ~ Dist_city, data = div_sum )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# Looks pretty normal

# Conclusion: No transformation needed.
```
####### With transects- SQUARING TRANSFORMATION 
```{r}

lm3 <- lm(shannon_equit ~ Dist_city * Transect, data = div_sum_urban )

par(mfrow=c(2,2))
plot(lm3)
lm3_sum <- summary(lm3)

## Histogram
gg_reshist(lm3, bins=20)

diagnostic(lm3$residuals)
# left skew

# Conclusion: Try a transformation: 
gg_reshist(lm(shannon_equit ~ Dist_city* Transect, data = div_sum_urban ), bins=10 ) 
gg_reshist(lm(shannon_equit^(2) ~ Dist_city* Transect, data = div_sum_urban ), bins=10 )

par(mfrow=c(2,2))
plot(lm(Menhinicks_index^2 ~ Dist_city * Transect, data = div_sum_urban ))

# Squaring makes it look much better.
```

#### ANOVA
##### Export to one csv- lm/glm
```{r}

# Start a sink file with a CSV extension
sink('pollinators_ANOVA.csv')

#### Abundance ####
## table 1
cat('Abundance- Q1')
cat('\n')
cat('P ~ dist_city')
cat('\n')
cat('Main Effect')
write.csv(ab.q1)
cat('\n')

## table 2
cat('Abundance- Q3')
cat('\n')
cat('P ~ dist_city + Transect_ID')
cat('\n')
cat('Main Effect')
write.csv(ab.q2)
cat('\n')
cat('\n')

#### Diversity ####
## table 1
cat('Simpsons Diversity- Q1')
cat('\n')
cat('p ~ City_dist')
cat('\n')
cat('Main Effect')
write.csv(di.q1)
cat('\n')

## table 2
cat('Simpsons Diversity- Q3')
cat('\n')
cat('P ~ City_dist + Transect')
cat('\n')
cat('Main Effect')
write.csv(di.q2)
cat('\n')
cat('\n')

##### Close the sink ####
sink()

```

##### Abundance
###### **Poisson-distributed glm data
####### All data
```{r}
# Total individuals ~ dist city ctr 
summary(glm(total_indivs ~ Dist_city, data = div_sum , family = "poisson"))
ab.q1 <- car::Anova(glm(total_indivs ~ Dist_city , data = div_sum, family = "poisson" ))
# Dist_city is sig


# pairs(lsmeans(abun_m1, "Transect"), adjust = "mvt")
# # The Rural and Southern Urban transects are significantly different from one another.
# # The Rural and Northern urban transects are significantly different from one another.
# # The 2 urban transects are not sig diff from e.o.
# 
# marginal = lsmeans(abun_m1, ~ Transect)
# 
# CLD = cld(marginal, alpha=0.05, Letters=letters, adjust="tukey")
# 
# ggplot(CLD, aes(x = Transect, y = lsmean, label = .group)) +
#     geom_point(shape  = 15,
#                size   = 4,
#              position = position_dodge(0.2) ) +
#     geom_errorbar(aes(ymin  =  lower.CL,
#                       ymax  =  upper.CL),
#                       width =  0.2,
#                       size  =  0.7,
#                    position = position_dodge(0.2) ) +
#     theme_bw() +
#     theme(axis.title   = element_text(face = "bold"),
#           axis.text    = element_text(face = "bold"),
#           plot.caption = element_text(hjust = 0)) +
#     ylab("Least square mean") +
#     ggtitle ("Pollinator Individuals per Site",
#              subtitle = "Least Square Mean")

```

####### Transects
```{r}
# Total individuals ~ dist city ctr *  Transect
summary(glm(total_indivs ~ Dist_city*Transect, data = div_sum_urban , family = "poisson"))
car::Anova(glm(total_indivs ~ Dist_city*Transect , data = div_sum_urban, family = "poisson" ))
# Nothing sig


# Total individuals ~ dist city ctr + Transect
summary(glm(total_indivs ~ Dist_city + Transect, data = div_sum_urban , family = "poisson"))
ab.q2 <- car::Anova(glm(total_indivs ~ Dist_city + Transect , data = div_sum_urban, family = "poisson" ))
# Nothing sig

```



####### Find abundance means at urban and rural terminii
```{r}
urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii


q.1 <- glm(total_indivs	~ Dist_city, data = div_sum, family = "poisson")
coeffs.q.1 = coefficients(q.1)

rural_mean = coeffs.q.1[1] + coeffs.q.1[2]*rural_terminus 
rural_mean # mean abundance

urban_mean = coeffs.q.1[1] + coeffs.q.1[2]*urban_terminus 
urban_mean # mean abundance

# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))

# FIND MEAN abundance
central_mean_q.1 = coeffs.q.1[1] + coeffs.q.1[2]*midpoint 
central_mean_q.1


# AVG DIFFERENCE FROM URBAN TO RURAL TERMINUS:
(urban_mean - rural_mean)/(0.5*(urban_mean + rural_mean))


```

##### Diversity
###### Shannon's Diversity Index
####### All data
```{r}
# Shannon diversity  ~ dist city ctr
summary(lm(shannon ~ Dist_city , data = div_sum ))
car::Anova(lm(shannon ~ Dist_city , data = div_sum ))
## city_dist nto sig

# pairs(lsmeans(sh_div_lm, "Transect"), adjust = "mvt")
# # No transects are signifcantly different from one another.
# # This is more trustworthy than the ANOVA because it accounts for the unbalanced design.
# 
# marginal1 = lsmeans(sh_div_lm, ~ Transect)
# CLD1 = cld(marginal1, alpha=0.05, Letters=letters, adjust="tukey")
# ggplot(CLD1, aes(x = Transect, y = lsmean, label = .group)) +
#     geom_point(shape  = 15,
#                size   = 4,
#              position = position_dodge(0.2) ) +
#     geom_errorbar(aes(ymin  =  lower.CL,
#                       ymax  =  upper.CL),
#                       width =  0.2,
#                       size  =  0.7,
#                    position = position_dodge(0.2) ) +
#     theme_bw() +
#     theme(axis.title   = element_text(face = "bold"),
#           axis.text    = element_text(face = "bold"),
#           plot.caption = element_text(hjust = 0)) +
#     ylab("Least square mean") +
#     ggtitle ("Shannon Diversity per Site",
#              subtitle = "Least Square Mean")
```


####### Transects
```{r}
# Shannon diversity  ~ dist city ctr *  Transect
summary(lm(shannon^(1/2) ~ Dist_city * Transect, data = div_sum_urban))
car::Anova(lm(shannon^(1/2) ~ Dist_city * Transect, data = div_sum_urban))
## A:B not significant, so let's try these main factors separately.

summary(lm(shannon^(1/2) ~ Dist_city+ Transect, data = div_sum_urban))
car::Anova(lm(shannon^(1/2) ~ Dist_city + Transect, data = div_sum_urban))
# nothing sig


# pairs(lsmeans(lm(shannon ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]), "Transect"), adjust = "mvt")
# # Marginally significant: p = 0.066
# 
# 
# 
# 
# marginal2 = lsmeans(lm(shannon ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]), ~ Transect)
# 
# CLD2 = cld(marginal2, alpha=0.05, Letters=letters, adjust="tukey")
# 
# ggplot(CLD2, aes(x = Transect, y = lsmean, label = .group)) +
#     geom_point(shape  = 15,
#                size   = 4,
#              position = position_dodge(0.2) ) +
#     geom_errorbar(aes(ymin  =  lower.CL,
#                       ymax  =  upper.CL),
#                       width =  0.2,
#                       size  =  0.7,
#                    position = position_dodge(0.2) ) +
#     theme_bw() +
#     theme(axis.title   = element_text(face = "bold"),
#           axis.text    = element_text(face = "bold"),
#           plot.caption = element_text(hjust = 0)) +
#     ylab("Least square mean") +
#     ggtitle ("Shannon Diversity per Site",
#              subtitle = "Least Square Mean")
# 

```

###### Simpson's Diversity Index
####### Transformed data (log(1-simpson) transformation. Was left-skewed)
######## All data
```{r}
# Simpson's diversity  ~ dist city ctr
summary(lm(log(1-simpson) ~ Dist_city , data = div_sum ))
di.q1 <- car::Anova(lm(log(1-simpson) ~ Dist_city , data = div_sum ))
## Nothing sig

```

######## Transects
```{r}
# Simpson's diversity  ~ dist city ctr * Transect
summary(lm(log(1-simpson) ~ Dist_city * Transect, data = div_sum_urban))
car::Anova(lm(log(1-simpson) ~ Dist_city * Transect, data = div_sum_urban))
## A:B not significant, so let's try these main factors separately.

di.q2 <- car::Anova(lm(log(1-simpson) ~ Dist_city + Transect, data = div_sum_urban))
# not sig
```

######## Removing honeybees (use sq transf w/o transects, cube with transects)
######### All data
```{r}
# Simpson's diversity  ~ dist city ctr
summary(lm(simpson_sq ~ Dist_city , data = div_sum_no_honey ))
car::Anova(lm(simpson_sq ~ Dist_city , data = div_sum_no_honey ))
## Nothing sig
 
```

######### Transects
```{r}
# Simpson's diversity  ~ dist city ctr * Transect
summary(lm(simpson_cube ~ Dist_city * Transect, data = div_sum_urban_no_honey))
car::Anova(lm(simpson_cube ~ Dist_city * Transect, data = div_sum_urban_no_honey))
## A:B not significant, so let's try these main factors separately.

car::Anova(lm(simpson_cube ~ Dist_city + Transect, data = div_sum_urban_no_honey))
# not sig
```

##### Richness
Main takeaway: Menhinick's Richness index does vary along the gradient and by transect- both when involving all 3 and only 2 urban transects. Their interaction is not significant.
```{r}

# Menhinick's Index ~ dist city ctr * Transect
summary(lm(Menhinicks_index ~ Dist_city * Transect, data = div_sum ))
car::Anova(lm(Menhinicks_index ~ Dist_city * Transect, data = div_sum ))
## A:B not significant but B (transect) is... so let's try these main factors separately.

# Menhinick's Index ~ dist city ctr
summary(lm(Menhinicks_index ~ Dist_city, data = div_sum ))
car::Anova(lm(Menhinicks_index ~ Dist_city, data = div_sum ))
## p < 0.01*
## Richness does change along the gradient!

# Menhinick's Index ~ transect
summary(lm(Menhinicks_index ~ Transect, data = div_sum ))
car::Anova(lm(Menhinicks_index ~ Transect, data = div_sum ))
## p < 0.001***
## Richness does vary among transects!


### URBAN TRANSECTS ONLY ###
# Menhinick's Index ~ dist city ctr * URBAN Transect
summary(lm(Menhinicks_index ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(Menhinicks_index ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## A:B not significant but B (transect) is... so let's try these main factors separately.

# Menhinick's Index ~ URBAN transect
summary(lm(Menhinicks_index ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(Menhinicks_index ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## p < 0.03*
## Richness does vary among urban transects!

```
 *** STILL NEED TO DO 4/3/2020- SET UP LM'S CORRECTLY & REDO
##### Equitability (Evenness)*** STILL NEED TO DO 4/3/2020- SET UP LM'S CORRECTLY & REDO
###### Shannon's Equitability
Main takeaway: Shannon's Equitability does not differ by position along gradient. It marginally differs by transect (when comparing all 3 as well as just the 2 urban). The interaction is not significant.
```{r}
# Shannon equitability  ~ dist city ctr * Transect
summary(lm(shannon_equit ~ Dist_city * Transect, data = div_sum ))
car::Anova(lm(shannon_equit ~ Dist_city * Transect, data = div_sum ))
## A:B not significant, so let's try these main factors separately.

# Shannon equitability ~ dist city ctr
summary(lm(shannon_equit ~ Dist_city, data = div_sum ))
car::Anova(lm(shannon_equit ~ Dist_city, data = div_sum ))
## p >> 0.05
## Shannon's equitability does NOT significantly change along the gradient

# Shannon equitability  ~ transect
summary(lm(shannon_equit ~ Transect, data = div_sum ))
car::Anova(lm(shannon_equit ~ Transect, data = div_sum ))
## p = 0.09
## Shannon's equitability varies among transects (it's marginally significant)


### URBAN TRANSECTS ONLY ###
# Shannon equitability  ~ dist city ctr * URBAN Transect
summary(lm(shannon_equit ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(shannon_equit ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## A:B not significant (though B is marginally sig), so let's try these main factors separately.

# Shannon equitability  ~ URBAN transect
summary(lm(shannon_equit ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(shannon_equit ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## p = 0.066
## Shannon's equitability does vary among urban transects (it's marginally significant)


```

###### Simpson's Equitability
Main takeaway: Simpson's Equitability does not differ by position along gradient or by transect. Their interaction is also not significant.
```{r}

# Simpson's equitability  ~ dist city ctr * Transect
summary(lm(simpson_equit ~ Dist_city * Transect, data = div_sum ))
car::Anova(lm(simpson_equit ~ Dist_city * Transect, data = div_sum ))
## A:B not significant, so let's try these main factors separately.

# Simpson diversity ~ dist city ctr
summary(lm(simpson_equit ~ Dist_city, data = div_sum ))
car::Anova(lm(simpson_equit ~ Dist_city, data = div_sum ))
## p >> 0.05
## Simpson's equitability does NOT significantly change along the gradient

# Simpson's equitability  ~ transect
summary(lm(simpson_equit ~ Transect, data = div_sum ))
car::Anova(lm(simpson_equit ~ Transect, data = div_sum ))
## p >> 0.05
## simpson_equit's diversity does NOT significantly vary among transects


### URBAN TRANSECTS ONLY ###
# Simpson's equitability  ~ dist city ctr * URBAN Transect
summary(lm(simpson_equit ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(simpson_equit ~ Dist_city * Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## A:B not significant, so let's try these main factors separately.

# Simpson's equitability  ~ URBAN transect
summary(lm(simpson_equit ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
car::Anova(lm(simpson_equit ~ Transect, data = div_sum[which(div_sum$Transect == "North" | div_sum$Transect == "South"),]))
## p >> 0.05
## simpson_equit's diversity does NOT significantly vary among urban transects

```

## Random Statistical Analysis (double-check these are using correctly transformed data + Anova instead of aov...)
#### Pollen Removal
##### R-sq, p, and n for each subtransect * year
```{r}

# stats for average pollen removal by year AND by sub-transect
## 2018
Poll_Nor_18 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "North"), ]))
Poll_Nor_18_n <- lm(Average_Pollinia ~ City_dist, 
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "North"), ])
Poll_Sou_18 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "South"), ]))
Poll_Sou_18_n <- lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "South"), ])
Poll_Rur_18 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "Rural"), ]))
Poll_Rur_18_n <- lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2018[which(AvgVars_byPatch_2018$Transect_ID == "Rural"), ])

## 2019
Poll_Nor_19 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "North"), ]))
Poll_Nor_19_n <- lm(Average_Pollinia ~ City_dist, 
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "North"), ])
Poll_Sou_19 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "South"), ]))
Poll_Sou_19_n <- lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "South"), ])
Poll_Rur_19 <- summary(lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "Rural"), ]))
Poll_Rur_19_n <- lm(Average_Pollinia ~ City_dist,
                    data = AvgVars_byPatch_2019[which(AvgVars_byPatch_2019$Transect_ID == "Rural"), ])


##### table w/summary stats for each subtransect by year
Pollen_removal_stats_table <-matrix(c(
  "2018",round(Poll_Nor_18$r.squared,3),round(Poll_Nor_18$coefficients[2,4],3),nobs(Poll_Nor_18_n),
  "2018",round(Poll_Sou_18$r.squared,3),round(Poll_Sou_18$coefficients[2,4],3),nobs(Poll_Sou_18_n),
  "2018",round(Poll_Rur_18$r.squared,3),round(Poll_Rur_18$coefficients[2,4],3),nobs(Poll_Rur_18_n),
  "2019",round(Poll_Nor_19$r.squared,3),round(Poll_Nor_19$coefficients[2,4],3),nobs(Poll_Nor_19_n),
  "2019",round(Poll_Sou_19$r.squared,3),round(Poll_Sou_19$coefficients[2,4],3),nobs(Poll_Sou_19_n),
  "2019",round(Poll_Rur_19$r.squared,3),round(Poll_Rur_19$coefficients[2,4],3),nobs(Poll_Rur_19_n))
  ,ncol=4,byrow=TRUE)
colnames(Pollen_removal_stats_table) <- c("Year","R-squared", "p", "n")
rownames(Pollen_removal_stats_table) <- c("Urban: Northern","Urban: Southern (green corridor)","Rural","Urban: Northern","Urban: Southern (green corridor)","Rural")
Pollen_removal_stats_table <- as.table(Pollen_removal_stats_table)
Pollen_removal_stats_table


##### table w/summary stats for each subtransect by subtransect
Pollen_removal_stats_table2 <-matrix(c(
"2018",round(Poll_Nor_18$r.squared,3),round(Poll_Nor_18$coefficients[2,4],3),nobs(Poll_Nor_18_n),
"2019",round(Poll_Nor_19$r.squared,3),round(Poll_Nor_19$coefficients[2,4],3),nobs(Poll_Nor_19_n),
                                      "2018",round(Poll_Sou_18$r.squared,3),round(Poll_Sou_18$coefficients[2,4],3),nobs(Poll_Sou_18_n),         "2019",round(Poll_Sou_19$r.squared,3),round(Poll_Sou_19$coefficients[2,4],3),nobs(Poll_Sou_19_n),
                                      "2018",round(Poll_Rur_18$r.squared,3),round(Poll_Rur_18$coefficients[2,4],3),nobs(Poll_Rur_18_n),        "2019",round(Poll_Rur_19$r.squared,3),round(Poll_Rur_19$coefficients[2,4],3),nobs(Poll_Rur_19_n)),
ncol=4,byrow=TRUE)
colnames(Pollen_removal_stats_table2) <- c("Year","R-squared", "p", "n")
rownames(Pollen_removal_stats_table2) <- c("Urban: Northern","Urban: Northern","Urban: Southern (green corridor)","Urban: Southern (green corridor)","Rural","Rural")
Pollen_removal_stats_table2 <- as.table(Pollen_removal_stats_table)
Pollen_removal_stats_table2
write.csv(Pollen_removal_stats_table2, "Poll_removal_stats2.csv")
```
##### Comparing urban, rural subtransects
```{r}

# ANOVA
## 2018
Poll_18_North <- subset(AvgVars_notNA_Poll_18, Transect_ID == "North", select = c("Average_Pollinia", "City_dist"))
Poll_18_South <- subset(AvgVars_notNA_Poll_18, Transect_ID == "South", select = c("Average_Pollinia", "City_dist"))
Poll_18_Urban <- subset(AvgVars_notNA_Poll_18, Transect_ID == "North" | Transect_ID == "South", select = c("Average_Pollinia", "City_dist", "Transect_ID"))

aov1 <- aov(Average_Pollinia ~ City_dist * Transect_ID, data = Poll_18_Urban)
summary(aov1)
Anova(aov1, type = "II")
lsmeans_poll18 <- lsmeans(aov1, ~Transect_ID)
lsmeans_poll18
## South has (1.6-1.04)/(1.04) = 54% more pollinia removed, on average, than North transect

## 2019
Poll_19_North <- subset(AvgVars_notNA_Poll_19, Transect_ID == "North", select = c("Average_Pollinia", "City_dist"))
Poll_19_South <- subset(AvgVars_notNA_Poll_19, Transect_ID == "South", select = c("Average_Pollinia", "City_dist"))
Poll_19_Urban <- subset(AvgVars_notNA_Poll_19, Transect_ID == "North" | Transect_ID == "South", select = c("Average_Pollinia", "City_dist", "Transect_ID"))

aov2 <- aov(Average_Pollinia ~ City_dist * Transect_ID, data = Poll_19_Urban)
summary(aov2)
Anova(aov2, type = "II")
lsmeans_poll19 <- lsmeans(aov2, ~Transect_ID)
lsmeans_poll19
## South has (0.845-0.801)/(0.801) = 5% more pollinia removed, on average, than North transect

## 2018-2019
Poll_North <- subset(AvgVars_notNA_Poll, Transect_ID == "North", select = c("Average_Pollinia", "City_dist"))
Poll_South <- subset(AvgVars_notNA_Poll, Transect_ID == "South", select = c("Average_Pollinia", "City_dist"))

##### can I do this for 2 years?? Or do I have to use lmer for more than my current 2 variables? (city_dist and transect ID)
aov3 <- aov(Average_Pollinia ~ City_dist * Transect_ID , data = Poll_Urban)
summary(aov3)
Anova(aov3, type = "II")
lsmeans_poll19 <- lsmeans(aov3, ~Transect_ID)
lsmeans_poll19
## South has (1.126-0.876)/(0.876) = 29% more pollen removal, on average, than North transect

```
#### Follicles
##### R-sq, p, and n for each subtransect * year
```{r}

# stats for average follicles by year AND by sub-transect
## 2018
Pod_Nor_18 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "North"), ]))
Pod_Nor_18_n <- lm(Total_Pods ~ City_dist, 
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "North"), ])

Pod_Sou_18 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "South"), ]))
Pod_Sou_18_n <- lm(Total_Pods ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "South"), ])

Pod_Rur_18 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "Rural"), ]))
Pod_Rur_18_n <- lm(Total_Pods ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "Rural"), ])

## 2019
Pod_Nor_19 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "North"), ]))
Pod_Nor_19_n <- lm(Total_Pods ~ City_dist, 
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "North"), ])

Pod_Sou_19 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "South"), ]))
Pod_Sou_19_n <- lm(Total_Pods ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "South"), ])

Pod_Rur_19 <- summary(lm(Total_Pods ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "Rural"), ]))
Pod_Rur_19_n <- lm(Total_Pods ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "Rural"), ])


##### table w/summary stats for each subtransect by year
Pods_stats_table <-matrix(c(
  "2018",round(Pod_Nor_18$r.squared,3),round(Pod_Nor_18$coefficients[2,4],3),nobs(Pod_Nor_18_n),
  "2018",round(Pod_Sou_18$r.squared,3),round(Pod_Sou_18$coefficients[2,4],3),nobs(Pod_Sou_18_n),
  "2018",round(Pod_Rur_18$r.squared,3),round(Pod_Rur_18$coefficients[2,4],3),nobs(Pod_Rur_18_n),
  "2019",round(Pod_Nor_19$r.squared,3),round(Pod_Nor_19$coefficients[2,4],3),nobs(Pod_Nor_19_n),
  "2019",round(Pod_Sou_19$r.squared,3),round(Pod_Sou_19$coefficients[2,4],3),nobs(Pod_Sou_19_n),
  "2019",round(Pod_Rur_19$r.squared,3),round(Pod_Rur_19$coefficients[2,4],3),nobs(Pod_Rur_19_n))
  ,ncol=4,byrow=TRUE)
colnames(Pods_stats_table) <- c("Year","R-squared", "p", "n")
rownames(Pods_stats_table) <- c("Urban: Northern","Urban: Southern (green corridor)","Rural","Urban: Northern","Urban: Southern (green corridor)","Rural")
Pods_stats_table <- as.table(Pods_stats_table)
Pods_stats_table


##### table w/summary stats for each subtransect by subtransect
Pods_stats_table2 <-matrix(c(
"2018",round(Pod_Nor_18$r.squared,3),round(Pod_Nor_18$coefficients[2,4],3),nobs(Pod_Nor_18_n),
"2019",round(Pod_Nor_19$r.squared,3),round(Pod_Nor_19$coefficients[2,4],3),nobs(Pod_Nor_19_n),
"2018",round(Pod_Sou_18$r.squared,3),round(Pod_Sou_18$coefficients[2,4],3),nobs(Pod_Sou_18_n),         "2019",round(Pod_Sou_19$r.squared,3),round(Pod_Sou_19$coefficients[2,4],3),nobs(Pod_Sou_19_n),
"2018",round(Pod_Rur_18$r.squared,3),round(Pod_Rur_18$coefficients[2,4],3),nobs(Pod_Rur_18_n),        "2019",round(Pod_Rur_19$r.squared,3),round(Pod_Rur_19$coefficients[2,4],3),nobs(Pod_Rur_19_n)),
ncol=4,byrow=TRUE)
colnames(Pods_stats_table2) <- c("Year","R-squared", "p", "n")
rownames(Pods_stats_table2) <- c("Urban: Northern","Urban: Northern","Urban: Southern (green corridor)","Urban: Southern (green corridor)","Rural","Rural")
Pods_stats_table2 <- as.table(Pods_stats_table2)
Pods_stats_table2
write.csv(Pods_stats_table2, "Pods_stats2.csv")
```
##### Comparing urban, rural subtransects
```{r}

# ANOVA
## 2018

aov1a <- aov(Total_Pods ~ City_dist * Transect_ID, data = Pod_18_Urban)
summary(aov1a)
Anova(aov1a, type = "II")
lsmeans_pod18 <- lsmeans(aov1a, ~Transect_ID)
lsmeans_pod18
## South has (4.99-3.35)/(3.35) = 49% more pods, on average, than North transect

## 2019

aov2a <- aov(Total_Pods ~ City_dist * Transect_ID, data = Pod_19_Urban)
summary(aov2a)
Anova(aov2a, type = "II")
lsmeans_pod19 <- lsmeans(aov2a, ~Transect_ID)
lsmeans_pod19
## South has (3.65-3.4)/(3.4) = 7% more pods, on average, than North transect

```
#### Peduncles
##### R-sq, p, and n for each subtransect * year
```{r}

# stats for average follicles by year AND by sub-transect
## 2018
Ped_Nor_18 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "North"), ]))
Ped_Nor_18_n <- lm(Peduncles ~ City_dist, 
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "North"), ])

Ped_Sou_18 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "South"), ]))
Ped_Sou_18_n <- lm(Peduncles ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "South"), ])

Ped_Rur_18 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "Rural"), ]))
Ped_Rur_18_n <- lm(Peduncles ~ City_dist,
                    data = fertile_pops_18[which(fertile_pops_18$Transect_ID == "Rural"), ])

## 2019
Ped_Nor_19 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "North"), ]))
Ped_Nor_19_n <- lm(Peduncles ~ City_dist, 
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "North"), ])

Ped_Sou_19 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "South"), ]))
Ped_Sou_19_n <- lm(Peduncles ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "South"), ])

Ped_Rur_19 <- summary(lm(Peduncles ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "Rural"), ]))
Ped_Rur_19_n <- lm(Peduncles ~ City_dist,
                    data = fertile_pops_19[which(fertile_pops_19$Transect_ID == "Rural"), ])


##### table w/summary stats for each subtransect by year
Peds_stats_table <-matrix(c(
  "2018",round(Ped_Nor_18$r.squared,3),round(Ped_Nor_18$coefficients[2,4],3),nobs(Ped_Nor_18_n),
  "2018",round(Ped_Sou_18$r.squared,3),round(Ped_Sou_18$coefficients[2,4],3),nobs(Ped_Sou_18_n),
  "2018",round(Ped_Rur_18$r.squared,3),round(Ped_Rur_18$coefficients[2,4],3),nobs(Ped_Rur_18_n),
  "2019",round(Ped_Nor_19$r.squared,3),round(Ped_Nor_19$coefficients[2,4],3),nobs(Ped_Nor_19_n),
  "2019",round(Ped_Sou_19$r.squared,3),round(Ped_Sou_19$coefficients[2,4],3),nobs(Ped_Sou_19_n),
  "2019",round(Ped_Rur_19$r.squared,3),round(Ped_Rur_19$coefficients[2,4],3),nobs(Ped_Rur_19_n))
  ,ncol=4,byrow=TRUE)
colnames(Peds_stats_table) <- c("Year","R-squared", "p", "n")
rownames(Peds_stats_table) <- c("Urban: Northern","Urban: Southern (green corridor)","Rural","Urban: Northern","Urban: Southern (green corridor)","Rural")
Peds_stats_table <- as.table(Peds_stats_table)
Peds_stats_table


##### table w/summary stats for each subtransect by subtransect
Peds_stats_table2 <-matrix(c(
"2018",round(Ped_Nor_18$r.squared,3),round(Ped_Nor_18$coefficients[2,4],3),nobs(Ped_Nor_18_n),
"2019",round(Ped_Nor_19$r.squared,3),round(Ped_Nor_19$coefficients[2,4],3),nobs(Ped_Nor_19_n),
"2018",round(Ped_Sou_18$r.squared,3),round(Ped_Sou_18$coefficients[2,4],3),nobs(Ped_Sou_18_n),         "2019",round(Ped_Sou_19$r.squared,3),round(Ped_Sou_19$coefficients[2,4],3),nobs(Ped_Sou_19_n),
"2018",round(Ped_Rur_18$r.squared,3),round(Ped_Rur_18$coefficients[2,4],3),nobs(Ped_Rur_18_n),        "2019",round(Ped_Rur_19$r.squared,3),round(Ped_Rur_19$coefficients[2,4],3),nobs(Ped_Rur_19_n)),
ncol=4,byrow=TRUE)
colnames(Peds_stats_table2) <- c("Year","R-squared", "p", "n")
rownames(Peds_stats_table2) <- c("Urban: Northern","Urban: Northern","Urban: Southern (green corridor)","Urban: Southern (green corridor)","Rural","Rural")
Peds_stats_table2 <- as.table(Peds_stats_table2)
Peds_stats_table2
write.csv(Peds_stats_table2, "Peds_stats2.csv")
```
##### Comparing urban, rural subtransects
```{r}

# ANOVA
## 2018


aov1b <- aov(Peduncles ~ City_dist * Transect_ID, data = Ped_18_Urban)
summary(aov1b)
Anova(aov1b, type = "II")
lsmeans_ped18 <- lsmeans(aov1b, ~Transect_ID)
lsmeans_ped18
## South has (8.67-7.16)/(7.16) = 21% more pods, on average, than North transect

## 2019


aov2b <- aov(Peduncles ~ City_dist * Transect_ID, data = Ped_19_Urban)
summary(aov2b)
Anova(aov2b, type = "II")
lsmeans_ped19 <- lsmeans(aov2b, ~Transect_ID)
lsmeans_ped19
## South has (8.47-7.97)/(7.97) = 6% more pods, on average, than North transect
```
#### Height
##### R-sq, p, and n for each subtransect * year
```{r}
# stats for average height by year AND by sub-transect
## 2018
Height_Nor_18 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "North"), ]))
Height_Nor_18_n <- lm(Height_Sept ~ City_dist, 
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "North"), ])

Height_Sou_18 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "South"), ]))
Height_Sou_18_n <- lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "South"), ])

Height_Rur_18 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "Rural"), ]))
Height_Rur_18_n <- lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_18[which(AvgVars_notNA_Height_18$Transect_ID == "Rural"), ])

## 2019
Height_Nor_19 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "North"), ]))
Height_Nor_19_n <- lm(Height_Sept ~ City_dist, 
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "North"), ])

Height_Sou_19 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "South"), ]))
Height_Sou_19_n <- lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "South"), ])

Height_Rur_19 <- summary(lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "Rural"), ]))
Height_Rur_19_n <- lm(Height_Sept ~ City_dist,
                    data = AvgVars_notNA_Height_19[which(AvgVars_notNA_Height_19$Transect_ID == "Rural"), ])


##### table w/summary stats for each subtransect by year
Height_stats_table <-matrix(c(
  "2018",round(Height_Nor_18$r.squared,3),round(Height_Nor_18$coefficients[2,4],3),nobs(Height_Nor_18_n),
  "2018",round(Height_Sou_18$r.squared,3),round(Height_Sou_18$coefficients[2,4],3),nobs(Height_Sou_18_n),
  "2018",round(Height_Rur_18$r.squared,3),round(Height_Rur_18$coefficients[2,4],3),nobs(Height_Rur_18_n),
  "2019",round(Height_Nor_19$r.squared,3),round(Height_Nor_19$coefficients[2,4],3),nobs(Height_Nor_19_n),
  "2019",round(Height_Sou_19$r.squared,3),round(Height_Sou_19$coefficients[2,4],3),nobs(Height_Sou_19_n),
  "2019",round(Height_Rur_19$r.squared,3),round(Height_Rur_19$coefficients[2,4],3),nobs(Height_Rur_19_n))
  ,ncol=4,byrow=TRUE)
colnames(Height_stats_table) <- c("Year","R-squared", "p", "n")
rownames(Height_stats_table) <- c("Urban: Northern","Urban: Southern (green corridor)","Rural","Urban: Northern","Urban: Southern (green corridor)","Rural")
Height_stats_table <- as.table(Height_stats_table)
Height_stats_table


##### table w/summary stats for each subtransect by subtransect
Height_stats_table2 <-matrix(c(
"2018",round(Height_Nor_18$r.squared,3),round(Height_Nor_18$coefficients[2,4],3),nobs(Height_Nor_18_n),
"2019",round(Height_Nor_19$r.squared,3),round(Height_Nor_19$coefficients[2,4],3),nobs(Height_Nor_19_n),
"2018",round(Height_Sou_18$r.squared,3),round(Height_Sou_18$coefficients[2,4],3),nobs(Height_Sou_18_n),     "2019",round(Height_Sou_19$r.squared,3),round(Height_Sou_19$coefficients[2,4],3),nobs(Height_Sou_19_n),
"2018",round(Height_Rur_18$r.squared,3),round(Height_Rur_18$coefficients[2,4],3),nobs(Height_Rur_18_n),     "2019",round(Height_Rur_19$r.squared,3),round(Height_Rur_19$coefficients[2,4],3),nobs(Height_Rur_19_n)),
ncol=4,byrow=TRUE)
colnames(Height_stats_table2) <- c("Year","R-squared", "p", "n")
rownames(Height_stats_table2) <- c("Urban: Northern","Urban: Northern","Urban: Southern (green corridor)","Urban: Southern (green corridor)","Rural","Rural")
Height_stats_table2 <- as.table(Height_stats_table2)
Height_stats_table2
write.csv(Height_stats_table2, "Height_stats2.csv")
```

##### Comparing urban, rural subtransects
```{r}

# ANOVA
## 2018
aov1c <- aov(Height_Sept ~ City_dist * Transect_ID, data = Height_18_Urban)
summary(aov1c)
Anova(aov1c, type = "II")
lsmeans_Height18 <- lsmeans(aov1c, ~Transect_ID)
lsmeans_Height18
## South plants are (97.7-86.7)/(86.7) = 13% taller, on average, than North transect plants


## 2019
aov2c <- aov(Height_Sept ~ City_dist * Transect_ID, data = Height_19_Urban)
summary(aov2c)
Anova(aov2c, type = "II")
lsmeans_Height19 <- lsmeans(aov2c, ~Transect_ID)
lsmeans_Height19 ()
## South plants are (102.3-95.1)/(95.1) = 8% taller, on average, than North transect plants
```